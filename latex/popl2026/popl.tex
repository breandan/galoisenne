%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan,nonacm]{acmart}
\documentclass[sigplan,review,acmsmall,nonacm,screen,anonymous]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
%\acmConference[SPLASH'24]{ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity}{October 22-27, 2024}{Pasadena, California, United States}
%\acmConference{}{}{}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{acmart}

\input{preamble}

\usepackage{draftwatermark}
\SetWatermarkLightness{0.75}
\SetWatermarkText{DRAFT}
\makeatletter
\let\@authorsaddresses\@empty
\makeatother

\begin{document}
%
\title{Syntax Repair as Language Intersection}
%
\begin{abstract}
  We introduce a new technique for correcting syntax errors in arbitrary context-free languages. Our work addresses the problem of syntax error correction, which we solve by defining a finite language that provably generates every repair within a certain edit distance. To do this, we adapt the Bar-Hillel construction from formal languages, guaranteeing the language is sound and complete with respect to the programming langauge grammar. This technique also admits a polylogarithmic time algorithm for deciding intersection nonemptiness between CFLs and acyclic NFAs, the first of its kind in the parsing literature.
  \keywords{Error correction \and CFL reachability \and Language games.}
\end{abstract}

%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
  \author{Breandan Considine}
  \email{bre@ndan.co}

  \maketitle

  \section{Introduction}

  During programming, one invariably encounters a certain scenario in which the editor occupies an unparseable state, either due to an unfinished or malformed piece of code. Faced with this predicament, programmers must spend time to locate and repair the error before proceeding. We attempt to solve this problem automatically by generating a list of candidate repairs which contains with high probability the true repair, assuming this repair differs by no more than a few edits.

  \section{Background}

  We will first give some background on Brozozowski differentiation. Let us consider the generalized regular expression (GRE) fragment containing concatenation, conjunction and disjunction:

  \begin{definition}[Generalized Regex]
    Let \( e \) be an expression defined by the grammar:
    \[
      e \Coloneqq \varnothing \mid \varepsilon \mid \Sigma \mid e \cdot e \mid e \lor e \mid e \land e
    \]

    Semantically, we can interpret these expressions as denoting regular languages:
    \setlength{\columnseprule}{0pt}
    \setlength{\columnsep}{-3cm}
    \begin{multicols}{2}
      \begin{eqnarray*}
        \mathcal{L}(& \varnothing & ) = \varnothing \\
        \mathcal{L}(& \varepsilon & ) = \{\varepsilon\} \\
        \mathcal{L}(& a           & ) = \{a\}
      \end{eqnarray*} \break\vspace{-0.45cm}
      \begin{eqnarray*}
        \mathcal{L}(& x\cdot z & ) = \mathcal{L}(x) \times \mathcal{L}(z)\text{\footnotemark}\\
        \mathcal{L}(& x\vee  z & ) = \mathcal{L}(x) \cup   \mathcal{L}(z)\\
        \mathcal{L}(& x\land z & ) = \mathcal{L}(x) \cap   \mathcal{L}(z)
      \end{eqnarray*}
    \end{multicols}
    \footnotetext{Or $\{a \cdot b \mid a \in \mathcal{L}(x) \land b \in \mathcal{L}(z) \}$ to be more precise, however we make no distinction.}
  \end{definition}

  Brzozowski introduces the concept of differentiation, which allows us to quotient a regular language by some given prefix.

  \begin{definition}[Brzozowski, 1964]
    To compute the quotient \(\partial_a(L) = \{b \mid ab \in L\}\), we:

    \vspace{-0.8cm}
    \begin{multicols}{2}
      \begin{eqnarray*}
        \phantom{--}\partial_a(& \varnothing &) = \varnothing                                           \\
        \phantom{--}\partial_a(& \varepsilon &) = \varnothing                                           \\
        \phantom{--}\partial_a(& b           &) = \begin{cases}\varepsilon &\text{ if } a = b\\ \varnothing &\text{ if } a \neq b \end{cases}\\
        \phantom{--}\partial_a(& x\cdot z    &) = (\partial_a x)\cdot z \vee \delta(x)\cdot\partial_a z \\
        \phantom{--}\partial_a(& x\vee  z    &) =  \partial_a x \vee  \partial_a z                       \\
        \phantom{--}\partial_a(& x\land z    &) =  \partial_a x \land \partial_a z
      \end{eqnarray*} \break\vspace{-0.45cm}
      \begin{eqnarray*}
        \delta(& \varnothing &) = \varnothing                                      \\
        \delta(& \varepsilon &) = \varepsilon                                      \\
        \delta(& a           &) = \varnothing\phantom{\begin{cases}\varepsilon\\\varnothing\end{cases}}\\
        \delta(& x\cdot z    &) = \delta(x) \land \delta(z)                        \\
        \delta(& x\vee  z    &) = \delta(x) \vee  \delta(z)                        \\
        \delta(& x\land z    &) = \delta(x) \land \delta(z)
      \end{eqnarray*}
    \end{multicols}
  \end{definition}

  Primarily, this gadget was designed to handle membership queries, for which purpose it has received considerable attention in recent years:

  \begin{theorem}[Recognition]
    For any regex \(e\) and \(\sigma: \Sigma^*\), \(\sigma \in \mathcal{L}(e) \Longleftrightarrow \varepsilon \in \mathcal{L}(\partial_\sigma e)\), where:

    \[
      \partial_\sigma (e): E \rightarrow E = \begin{cases}e &\text{ if } \sigma = \varepsilon\\\partial_b(\partial_a e) &\text{ if } \sigma = a \cdot b, a \in \Sigma, b \in \Sigma^* \end{cases}
    \]
  \end{theorem}

  It can also be used, however, to decode witnesses. We will first focus on the nonempty disjunctive fragment, and define this process in two steps:

  \begin{theorem}[Generation]
    For any nonempty $(\varepsilon, \land)$-free regex, \(e\), to witness $\sigma \in \mathcal{L}(e)$:\\

    $\texttt{follow}(e):E \rightarrow 2^\Sigma$ = \begin{cases}
     \{e\} &\text{ if } e \in \Sigma \\
     \texttt{follow}(x) &\text{ if } e = x \cdot z\\
     \texttt{follow}(x)\cup\texttt{follow}(z) &\text{ if } e = x \lor z
    \end{cases}\\\\

    $\texttt{choose}(e):E \rightarrow \Sigma^+$ = \begin{cases}
     e &\text{ if } e \in \Sigma \\
     \big(s \stackrel{\$}{\leftarrow} \texttt{follow}(e)\big)\cdot \texttt{choose}(\partial_s e) &\text{ if } e = x \cdot z\\
     \texttt{choose}(e' \stackrel{\$}{\leftarrow} \{x, z\}) &\text{ if } e = x \lor z
    \end{cases}
  \end{theorem}

Here, we use the $\stackrel{\$}{\leftarrow}$ operator to denote probabilistic choice, however any deterministic choice function will also suffice to generate a witness. Now we are equipped to handle conjunction.

\subsection{Language intersection}

  \begin{theorem}[Bar-Hillel, 1961]
    For any context-free grammar (CFG), $G = \langle V, \Sigma, P, S\rangle$, and nondeterministic finite automata, $A = \langle Q, \Sigma, \delta, I, F\rangle$, there exists a CFG \(G_\cap=\langle V_\cap, \Sigma_\cap, P_\cap, S_\cap\rangle\) such that $\mathcal{L}(G_\cap) = \mathcal{L}(G)\cap\mathcal{L}(A)$.
  \end{theorem}

  \begin{definition}[Salomaa, 1973]
    One could construct $G_\cap$ like so,

    \noindent\begin{prooftree}
        \hskip -1em
        \AxiomC{$q \in I \phantom{\land} r \in F\vphantom{\overset{a}{\rightarrow}}$}
        \RightLabel{$\sqrt{\phantom{S}}$}
        \UnaryInfC{$\big(S\rightarrow q S r\big) \in P_\cap$}
        \DisplayProof
        \hskip 1em
        \AxiomC{$(w \rightarrow a) \in P$}
        \AxiomC{$(q\overset{a}{\rightarrow}r) \in \delta$}
        \RightLabel{$\uparrow$}
        \BinaryInfC{$\big(qwr\rightarrow a\big)\in P_\cap$}
        \DisplayProof
        \hskip 1em
        \AxiomC{$(w \rightarrow xz) \in P$}
        \AxiomC{$\vphantom{(}p,q,r \in Q$}
        \RightLabel{$\Join$}
        \BinaryInfC{$\big(pwr\rightarrow (pxq)(qzr)\big) \in P_\cap$}
    \end{prooftree}
  \end{definition}

  However most synthetic productions in $P_\cap$ will be non-generating or unreachable. This naive method will construct a synthetic production for state pairs which are not even reachable, which is excessive. We will instead proceed by constructing a parse chart that represents the intersection.

  \begin{theorem}%[Considine, 2025]
    For every CFG, G, and every acyclic NFA (ANFA), A, there exists a decision procedure $\varphi: \text{CFG} \rightarrow \text{ANFA} \rightarrow \mathbb{B}$ such that $\varphi(G, A) \models [\mathcal{L}(G)\cap\mathcal{L}(A) \neq \varnothing]$ which requires $\mathcal{O}\big((\log |Q|)^c\big)$ time using $\mathcal{O}\big((|V||Q|)^k\big)$ parallel processors for some $c, k < \infty$.
  \end{theorem}

  \begin{proof}[Proof sketch]
    WTS there exists a path $p \rightsquigarrow r$ in A such that $p\in I, r\in F$ where $p \rightsquigarrow r \vdash S$.\vspace{0.3cm}

    \noindent There are two cases, at least one of which must hold for $w \in V$ to parse a given $p \rightsquigarrow r$ pair:

    \begin{enumerate}
      \item $p$ steps directly to $r$ in which case it suffices to check $\exists a.\big((p \overset{a}{\rightarrow} r)\in \delta \land (w \rightarrow a) \in P\big)$, or,
      \item there is some midpoint $q \in Q$, $p \rightsquigarrow q \rightsquigarrow r$ such that $\exists x, z.\big((w \rightarrow xz) \in P\land\overbrace{\underbrace{p \rightsquigarrow q}_x, \underbrace{q \rightsquigarrow r}_z}^w\big)$.
    \end{enumerate}

    \noindent This decomposition immediately suggests a dynamic programming solution. Let M be a matrix of type $RE^{|Q|\times|Q|\times|V|}$  indexed by $Q$. Since we assumed $\delta$ is acyclic, there exists a topological sort of $\delta$ imposing a total order on $Q$ such that $M$ is strictly upper triangular (SUT). Initiate it thusly:

    \begin{align}
      M_0[r, c, w] = \bigvee_{a\:\in\:\Sigma} \{a \mid (w \rightarrow a) \in P \land (q_r \overset{a}{\rightarrow} q_c)\in \delta\}
    \end{align}

    \noindent The algebraic operations $\oplus, \otimes: RE^{2|V|} \rightarrow RE^{|V|}$ will be defined elementwise:

    \begin{align}
      [\ell \oplus r]_w  &= [\ell_w \lor r_w]\\
      [\ell \otimes r]_w &= \bigvee_{\mathclap{x, z\:\in\:V}}\{\ell_x \cdot r_z \mid (w \rightarrow xz) \in P\}
    \end{align}

    \noindent By slight abuse of notation\footnote{Traditionally, there is a $\frac{1}{k!}$ factor to suppress exploding entries.}, we will redefine the matrix exponential over this domain as:

    \begin{align}
      \exp(M) &= \sum_{i = 0}^\infty M_0^i = \sum_{i = 0}^{|Q|} M_0^i \text { (since $M$ is SUT.)}
    \end{align}

    \noindent To solve for the fixpoint, we can instead use exponentiation by squaring:

    \begin{align}
      S(2n) \;=\; \begin{cases}
         M_0, & \text{if } n = 1,\\[6pt]
         S(n) + S(n)^2 & \text{otherwise}.
      \end{cases}
    \end{align}

    \noindent Therefor, we only need a maximum of $\lceil\log_2 |Q|\rceil$ sequential steps to reach the fixpoint. Finally,

    \begin{align}
      S_\cap = \bigvee_{\mathclap{q \in I,\:q' \in F}}\exp(M)[q, q', S] \text{ and } \varphi = [S_\cap \neq \varnothing]
    \end{align}

    \noindent To decode a witness in case of non-emptiness, we simply $\texttt{choose}(S_\cap)$.
  \end{proof}

  \subsection{Combinatorics}

  To enumerate, we first need $|\mathcal{L}(e)|$, which is denoted $|e|$ for brevity.

  \begin{definition}[Cardinality]
    $|e|: E \rightarrow \mathbb{N} =$ \begin{cases}
      1  & \text{if } R \in \Sigma \\
      x \times z  & \text{if } e = x \cdot z \\
      x + z  & \text{if } e = x \vee z
    \end{cases}\\
  \end{definition}

  \begin{theorem}[Enumeration]
    To enumerate, invoke $\bigcup_{i = 0}^{|R|}\{\texttt{enum}(R, i)\}$:\\

    $\texttt{enum}(e, n): E \times \mathbb{N} \rightarrow \Sigma^*$ = \begin{cases}
         e &\text{if } R \in \Sigma \\
         \texttt{enum}\big(x, \lfloor \frac{n}{|z|} \rfloor\big) \cdot \texttt{enum}\big(z,\, n \bmod |z|\big)  &\text{if } e = x \cdot z \\
         \texttt{enum}\big((x, z)_{\min(1, \lfloor\frac{n}{|x|}\rfloor)}, n-|x|\min(1, \lfloor\frac{n}{|x|}\rfloor)\big) &\text{if } e = x \vee z
    \end{cases}\\\\
  \end{theorem}

\end{document}