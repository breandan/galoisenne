\documentclass{beamer}
\usetheme{Madrid}
\beamertemplatenavigationsymbolsempty

\input{../preamble.tex}

\usepackage{pgf-soroban}
\usetikzlibrary{shapes.geometric,calc,decorations.text,bayesnet,arrows,backgrounds}
\usepackage{circledsteps}
\usepackage{epigraph}
\usepackage{array}
\setmonofont{JetBrains Mono}[
  Contextuals = Alternate,
  Ligatures = TeX,
]
\lstset{
  basicstyle = \ttfamily,
  columns = flexible,
}
\makeatletter
\renewcommand*\verbatim@nolig@list{}
\makeatother
\usepackage{pmboxdraw}
\usetikzlibrary{cd}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\usepackage{qrcode}

\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.25\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
      \usebeamerfont{author in head/foot}\insertshortauthor{}{~~(\insertshortinstitute)}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.45\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
      \usebeamerfont{title in head/foot}\insertshorttitle
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
      \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
      \insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
    \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\makeatletter
\let\HL\hl
\renewcommand\hl{%
  \let\set@color\beamerorig@set@color
  \let\reset@color\beamerorig@reset@color
  \HL}
\makeatother

\newcommand\ddd{\Ddots}
\newcommand\vdd{\Vdots}
\newcommand\cdd{\Cdots}
\newcommand\lds{\ldots}
\newcommand\vno{\varnothing}
\newcommand{\ts}[1]{\textsuperscript{#1}}
\newcommand\non{1\ts{st}}
\newcommand\ntw{2\ts{nd}}
\newcommand\nth{3\ts{rd}}
\newcommand\nfo{4\ts{th}}
\newcommand\nfi{5\ts{th}}
\newcommand\nsi{6\ts{th}}
\newcommand\nse{7\ts{th}}
\newcommand{\vs}[1]{\sigma_{#1}^{\shur}}
\newcommand\rcr{\rowcolor{black!15}}
\newcommand\rcw{\rowcolor{white}}
\newcommand\pcd{\cdot}
\newcommand\pcp{\phantom\cdot}
\newcommand\ppp{\phantom{\nse}}
\newcommand\hole{\underline{\hspace{0.25cm}}}

\title[A Tree Sampler for Bounded CFLs]{A Tree Sampler for Bounded Context-Free Languages}
\titlegraphic{\includegraphics[width=0.2\textwidth]{../../figures/tidyparse_logo.png}}
\author[Considine]{\textbf{Breandan Considine}}
\institute[McGill]{
  McGill University, Mila IQIA\\
  \medskip
  \textit{bre@ndan.co}
}
\date{\today}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[fragile]{A brief primer on CFL recognition}
  Given a CFG $\mathcal{G} \coloneqq \langle V, \Sigma, P, S\rangle$ in Chomsky Normal Form, we can construct a recognizer $R_\mathcal{G}: \Sigma^n \rightarrow \mathbb{B}$ for strings $\sigma: \Sigma^n$ as follows. Let $2^V$ be our domain, $0$ be $\varnothing$, $\oplus$ be $\cup$, and $\otimes$ be defined as follows:

  \vspace{-7pt}
  \[
    s_1 \otimes s_2 \coloneqq \{C \mid \langle A, B\rangle \in s_1 \times s_2, (C\rightarrow AB) \in P\}\\
    \text{e.g.},
    \{A \rightarrow BC, C \rightarrow AD, D \rightarrow BA\} \subseteq P \vdash \{A, B, C\} \otimes \{B, C, D\} = \{A, C\}
  \]
  \vspace{-1.5cm}

  \noindent If we define $\sigma_r^{\shur} \coloneqq \{w \mid (w \rightarrow \sigma_r) \in P\}$, then initialize $M^0_{r+1=c}(\mathcal{G}', e) := \;\sigma_r^{\shur}$ and solve for the fixpoint $M^* = M + M^2$,\vspace{-10pt}

  \begin{align*}
    M^0:=
    \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
      \varnothing & \sigma_1^\shri & \varnothing & \Cdots & \varnothing \\
      \Vdots      & \Ddots         & \Ddots      & \Ddots & \Vdots\\
      &                &             &        & \varnothing\\
      &                &             &        & \sigma_n^\shup \\
      \varnothing & \Cdots         &             &        & \varnothing
    \end{pNiceMatrix} &\Rightarrow \ldots \Rightarrow M^* =
    \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
      \varnothing & \sigma_1^\shri & \Lambda & \Cdots & \Lambda^*_\sigma\\
      \Vdots      & \Ddots         & \Ddots  & \Ddots & \Vdots\\
      &                &         &        & \Lambda\\
      &                &         &        & \sigma_n^\shup \\
      \varnothing & \Cdots         &         &        & \varnothing
    \end{pNiceMatrix}
  \end{align*}

  \noindent $S \Rightarrow^* \sigma \iff \sigma \in \mathcal{L}(\mathcal{G})$ iff $S \in \Lambda^*_\sigma$, i.e., $\mathds{1}_{\Lambda^*_\sigma}(S) \iff \mathds{1}_{\mathcal{L}(\mathcal{G})}(\sigma)$.
\end{frame}

\begin{frame}[fragile]{Satisfiability + holes (our contribution)}
  \begin{itemize}
    \item Can be lowered onto a Boolean tensor $\mathbb{B}^{n\times n \times |V|}$ (Valiant, 1975)
    \item Binarized CYK parser can be efficiently compiled to a SAT solver
    \item Enables sketch-based synthesis in either $\sigma$ or $\mathcal G$: just use variables!
    \item We simply encode the characteristic function, i.e. $\mathds{1}_{\subseteq V}: 2^V\rightarrow \mathbb{B}^{|V|}$
    \item $\oplus, \otimes$ are defined as $\boxplus, \boxtimes$, so that the following diagram commutes:
    \[\begin{tikzcd}
        2^V \times 2^V \arrow[r, "\oplus/\otimes"] \arrow[d, "\mathds{1}^2"]
        & 2^V \arrow[d, "\mathds{1}\phantom{^{-1}}"] \\
        \mathbb{B}^{|V|} \times \mathbb{B}^{|V|} \arrow[r, "\boxplus/\boxtimes", labels=below] \arrow[u, "\mathds{1}^{-2}"]
        & \mathbb{B}^{|V|} \arrow[u, "\mathds{1}^{-1}"]
    \end{tikzcd}\]
    \item These operators can be lifted into matrices/tensors in the usual way
    \item In most cases, only a few nonterminals are active at any given time
%    \item More sophisticated representations are known for $\binom{n}{0 \leq k}$ subsets
%    \item If density is desired, possible to use the Maculay representation
%            \item Set joins are an active topic of research in SQL query optimization
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Satisfiability + holes (our contribution)}
  Let us consider an example with two holes, $\sigma = 1$ \hole\phantom{.}\hole, and the grammar being $G\coloneqq\{S\rightarrow N O N, O \rightarrow + \mid \times, N \rightarrow 0 \mid 1\}$. This can be rewritten into CNF as $G'\coloneqq \{S \rightarrow N L, N \rightarrow 0 \mid 1, O \rightarrow × \mid +, L \rightarrow O N\}$. Using the algebra where $\oplus=\cup$, $X \otimes Z = \big\{\;w \mid \langle x, z\rangle \in X \times Z, (w\rightarrow xz) \in P\;\big\}$, the fixpoint $M' = M + M^2$ can be computed as follows:\\\vspace{10pt}

  \resizebox{\textwidth}{!}{
      {\renewcommand{\arraystretch}{1.2}
    \noindent\phantom{...}\begin{tabular}{|c|c|c|c|}
                            \hline
                            & $2^V$ & $\mathbb{B}^{|V|}$ & $\mathbb{B}^{|V|}\rightarrow\mathbb{B}^{|V|}$\\\hline
                            $M_0$ & \begin{pmatrix}
                                      \phantom{V} & \tiny{\{N\}} &         &             \\
                                      &              & \{N,O\} &             \\
                                      &              &         & \{N,O\} \\
                                      &              &         &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & \ws\bs\ws\ws &              &              \\
                                              &              & \ws\bs\bs\ws &              \\
                                              &              &              & \ws\bs\bs\ws \\
                                              &              &              &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & V_{0, 1} &          &          \\
                                              &          & V_{1, 2} &          \\
                                              &          &          & V_{2, 3} \\
                                              &          &          &
                            \end{pmatrix} \\\hline
                            $M_1$ & \begin{pmatrix}
                                      \phantom{V} & \tiny{\{N\}} & \varnothing &         \\
                                      &              & \{N,O\}     & \{L\}   \\
                                      &              &             & \{N,O\} \\
                                      &              &             &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & \ws\bs\ws\ws & \ws\ws\ws\ws &              \\
                                              &              & \ws\bs\bs\ws & \bs\ws\ws\ws \\
                                              &              &              & \ws\bs\bs\ws \\
                                              &              &              &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & V_{0, 1} & V_{0, 2} &          \\
                                              &          & V_{1, 2} & V_{1, 3} \\
                                              &          &          & V_{2, 3} \\
                                              &          &          &
                            \end{pmatrix} \\\hline
                            $M_\infty$ & \begin{pmatrix}
                                           \phantom{V} & \tiny{\{N\}} & \varnothing & \{S\}   \\
                                           &              & \{N,O\}     & \{L\}   \\
                                           &              &             & \{N,O\} \\
                                           &              &             &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & \ws\bs\ws\ws & \ws\ws\ws\ws & \ws\ws\ws\bs \\
                                              &              & \ws\bs\bs\ws & \bs\ws\ws\ws \\
                                              &              &              & \ws\bs\bs\ws \\
                                              &              &              &
                            \end{pmatrix} & \begin{pmatrix}
                                              \phantom{V} & V_{0, 1} & V_{0, 2} & V_{0, 3} \\
                                              &          & V_{1, 2} & V_{1, 3} \\
                                              &          &          & V_{2, 3} \\
                                              &          &          &
                            \end{pmatrix}\\\hline
    \end{tabular}
    }
  }
\end{frame}

\begin{frame}[fragile]{Semiring algebras: Part I}
  The prior solution tell us whether $A(\sigma)$ is nonempty, but forgets the solution(s). To solve for $A(\sigma)$, a na\"ive approach accumulates a mapping of nonterminals to sets of strings. Letting $D = V \rightarrow \mathcal{P}(\Sigma^*)$, we define $\oplus, \otimes: D \times D \rightarrow D$. Initially, we construct $M_0[r+1=c] = p(\sigma_r)$ using:

  \begin{equation*}
    p(s: \Sigma) \mapsto \{w \mid (w \rightarrow s)\in P\} \text{ and } p(\hole) \mapsto \bigcup_{s\in \Sigma} p(s)
  \end{equation*}

  $p(\cdot)$ constructs the superdiagonal, then we solve for $\Lambda_\sigma^*$ using the algebra:

  \begin{equation*}
    X \oplus Z \mapsto \big\{w \stackrel{+}{\Rightarrow} (X \circ w) \cup (Z \circ w) \mid w \in \pi_1(X \cup Z)\big\}
  \end{equation*}

  \begin{equation*}
    X \otimes Z \mapsto \bigoplus_{w, x, z}\big\{w \stackrel{+}{\Rightarrow} (X\circ x)(Z\circ z) \mid (w\rightarrow xz) \in P, x\in X, z\in Z\big\}
  \end{equation*}

  \noindent After $M_\infty$ is attained, the solutions can be read off via $\Lambda_\sigma^* \circ S$. The issue here is exponential growth when eagerly computing the transitive closure.
\end{frame}

\begin{frame}[fragile]{Semiring algebras: Part II}
  The prior encoding can be improved using an ADT $\mathbb{T}_3 = (V \cup \Sigma) \rightharpoonup \mathbb{T}_2$ where $\mathbb{T}_2 = (V \cup \Sigma) \times (\mathbb{N} \rightharpoonup \mathbb{T}_2\times\mathbb{T}_2)$. We construct $\hat\sigma_r = \dot{p}(\sigma_r)$ using:

  \begin{equation*}
    \dot{p}(s: \Sigma) \mapsto \Big\{\mathbb{T}_2\big(w, \big[\langle\mathbb{T}_2(s), \mathbb{T}_2(\varepsilon)\rangle\big]\big) \mid (w \rightarrow s)\in P\Big\} \text{ and } \dot{p}(\hole) \mapsto \bigoplus_{s\in \Sigma} p(s)
  \end{equation*}

  \noindent We then compute the fixpoint $M_\infty$ by redefining $\oplus, \otimes: \mathbb{T}_3 \times \mathbb{T}_3 \rightarrow \mathbb{T}_3$ as:

  \begin{equation*}
    X \oplus Z \mapsto \bigcup_{\mathclap{k\in \pi_1(X \cup Z)}}\Big\{k \Rightarrow \mathbb{T}_2(k, x \cup z) \mid x \in \pi_2(X\circ k), z \in \pi_2(Z\circ k)\Big\}
  \end{equation*}

  \begin{equation*}
    X \otimes Z \mapsto \bigoplus_{\mathclap{(w\rightarrow xz) \in P}}\Big\{\mathbb{T}_2\big(w, \big[\langle X\circ x, Z\circ z\rangle\big]\big) \mid x \in \pi_1(X), z \in \pi_1(Z)\Big\}
  \end{equation*}
\end{frame}

\begin{frame}{$\mathbb{T}_3$ join and merge semantics}
  \begin{prooftree}
    \AxiomC{
      \begin{tabular}{cc}
        \begin{tikzpicture}
        [
          grow                    = right,
          sibling distance        = 2em,
          level distance          = 3em,
          edge from parent/.style = {draw, -latex},
          every node/.style       = {font=\footnotesize},
          sloped
        ]
          \node [root] {B}
          child { node [env] {\ldots} edge from parent node [below] }
        \end{tikzpicture} & \raisebox{0.15cm}{$\in s_1$}\\
        \begin{tikzpicture}
        [
          grow                    = right,
          sibling distance        = 2em,
          level distance          = 3em,
          edge from parent/.style = {draw, -latex},
          every node/.style       = {font=\footnotesize},
          sloped
        ]
          \node [root] {C}
          child { node [env] {\ldots} edge from parent node [below] }
        \end{tikzpicture} & \raisebox{0.15cm}{$\in s_2$}
      \end{tabular}
    }
    \AxiomC{$s_1 \otimes s_2$}
    \AxiomC{$[A\rightarrow BC] \in P$}
    \RightLabel{$\otimes$}
    \TrinaryInfC{
      \begin{tikzpicture}
      [
        grow                    = right,
        sibling distance        = 2em,
        level distance          = 3em,
        edge from parent/.style = {draw, -latex},
        every node/.style       = {font=\footnotesize},
        sloped
      ]
        \node [root] {A}
        child {
          node [env] {BC}
          child { node [root] {B}
          child { node [env] {\ldots} edge from parent node [below] }
          edge from parent node [above] }
          child { node [root] {C}
          child { node [env] {\ldots} edge from parent node [below] }
          edge from parent node [above] }
          edge from parent node [above]
        }
      \end{tikzpicture}
    }
  \end{prooftree} \vspace{0.5cm}
  \begin{prooftree}
    \AxiomC{
      \begin{tabular}{cc}
        \begin{tikzpicture}
        [
          grow                    = right,
          sibling distance        = 2em,
          level distance          = 3em,
          edge from parent/.style = {draw, -latex},
          every node/.style       = {font=\footnotesize},
          sloped
        ]
          \node [root] {A}
          child { node [env] {CD}
          child { node [root] {\ldots} }
          edge from parent node [above] }
          child { node [env] {BC}
          child { node [root] {\ldots} }
          edge from parent node [below] }
        \end{tikzpicture} & \raisebox{0.5cm}{$\in s_1$}\\
        \begin{tikzpicture}
        [
          grow                    = right,
          sibling distance        = 2em,
          level distance          = 3em,
          edge from parent/.style = {draw, -latex},
          every node/.style       = {font=\footnotesize},
          sloped
        ]
          \node [root] {A}
          child { node [env] {BC}
          child { node [root] {\ldots} }
          edge from parent node [below] }
        \end{tikzpicture} & \raisebox{0.15cm}{$\in s_2$}
      \end{tabular}
    }
    \AxiomC{$s_1 \oplus s_2$}
    \RightLabel{$\oplus$}
    \BinaryInfC{
      \begin{tikzpicture}
      [
        grow                    = right,
        sibling distance        = 2em,
        level distance          = 3em,
        edge from parent/.style = {draw, -latex},
        every node/.style       = {font=\footnotesize},
        sloped
      ]
        \node [root] {A}
        child { node [env] {CD}
        child { node [root] {\ldots} }
        edge from parent node [above] }
        child { node [env] {BC}
        child { node [root] {\ldots} }
        edge from parent node [above] }
        child { node [env] {BC}
        child { node [root] {\ldots} }
        edge from parent node [below] }
      \end{tikzpicture}
    }
  \end{prooftree}
\end{frame}

\begin{frame}[fragile]{Semiring algebras: Part III}
  \begin{equation*}
    \hspace{-3cm}L(p) = 1 + p L(p) \phantom{space} P(a) = \Sigma + V + V L\big(P(a)^2\big)
  \end{equation*}
  \vspace{-1cm}\begin{figure}[H]
                 \resizebox{0.9\columnwidth}{!}{
                   \begin{tikzpicture}
                   [
                     grow                    = right,
                     sibling distance        = 3em,
                     level distance          = 5em,
                     edge from parent/.style = {draw, -latex},
                     every node/.style       = {font=\footnotesize},
                     sloped
                   ]
                     \node [root] {S}
                     child { node [env] {BC}
                     child { node [root] {B}
                     child { node [env] {RD}
                     child { node [root] {R} edge from parent node [above] }
                     child { node [root] {D} edge from parent node [above] }
                     edge from parent node [above] }
                     edge from parent node [below] }
                     child { node [root] {C}
                     child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
%  child { edge from parent node [above] {\ldots} }
                     edge from parent node [below] }
                     edge from parent node [above] }
                     child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
                     child { node [env] {AB}
                     child { node [root] {A}
                     child {
                       node [env] {QC}
                       child { node [root] {Q} edge from parent node [above] }
                       child { node [root] {C} edge from parent node [above] }
                       edge from parent node [above]
                     }
%    child { node [env] {ZQ} edge from parent node [above] }
                     child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
                     edge from parent node [below] }
                     child { node [root] {B}
                     child { node [env] {RD}
                     child { node [root] {R} edge from parent node [above] }
                     child { node [root] {D} edge from parent node [above] }
                     edge from parent node [above] }
                     edge from parent node [below] }
                     edge from parent node [above] };
                   \end{tikzpicture}
                 }
                 \vspace{-0.5cm}\caption{A partial $\mathbb{T}_2$ for the grammar with productions $P=\{S \rightarrow BC \mid \ldots \mid AB, B\rightarrow RD \mid \ldots, A\rightarrow QC \mid \ldots\}$.}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Sampling trees with replacement}
  Given a probabilistic CFG whose productions indexed by each nonterminal are decorated with a probability vector $\mathbf{p}$ (this may be uniform in the non-probabilistic case), we define a tree sampler $\Gamma: \mathbb{T}_2 \rightsquigarrow \mathbb{T}$ which recursively samples children according to a Multinoulli distribution:

  \begin{equation*}
    \Gamma(T) \mapsto \begin{cases}
                        \text{Multi} \big(\texttt{children}(T), \mathbf{p}\big) & \text{ if $T$ is a \texttt{root}} \\
                        \big\langle \Gamma\big(\pi_1(T)\big), \Gamma\big(\pi_2(T)\big) \big\rangle & \text{ if $T$ is a \texttt{child} }
    \end{cases}
  \end{equation*}

  This is closely related to the generating function for the ordinary Boltzmann sampler from analytic combinatorics,

  \begin{equation*}
    \Gamma C(x) \mapsto \begin{cases}
                          \text{Bern} \left(\frac{A(x)}{A(x) + B(x)}\right) \rightarrow \Gamma A(x) \mid \Gamma B(x) & \text{ if } \mathcal{C}=\mathcal{A}+\mathcal{B} \\
                          \big\langle \Gamma A(x), \Gamma B(x)\big\rangle & \text{ if } \mathcal{C}=\mathcal{A} \times \mathcal{B}
    \end{cases}
  \end{equation*}

  \noindent however unlike Duchon et al. (2004), rejection is unnecessary to ensure exact-size sampling, as all trees in $\mathbb{T}_2$ will necessarily be the same size.
\end{frame}

\begin{frame}[fragile]{A pairing function for replacement-free tree sampling}
  The total number of trees induced by a given sketch template is given by:

  \begin{equation*}
    |T: \mathbb{T}_2| \mapsto \begin{cases}
%    \big|\{s \mid \big(\texttt{root}(T) \rightarrow s\big) \in P_\cap\}\big| & \text{if $T$ is a leaf,} \\
                                1  & \text{if $T$ is a leaf,} \\
                                \sum_{\langle T_1, T_2\rangle \in \texttt{children}(T)} |T_1| \cdot |T_2| & \text{otherwise.}
    \end{cases}
  \end{equation*}\\

  To sample from $\mathbb{T}_2$ without replacement, we define a pairing function:

  \begin{equation*}
    \varphi^{-1}(T: \mathbb{T}_2, i: \mathbb{Z}_{|T|}) \mapsto \begin{cases}
                                                                 \Big\langle\texttt{BTree}\big(\texttt{root}(T)\big), i\Big\rangle & \text{if $T$ is a leaf,} \vspace{5pt}\\
                                                                 \text{Let } b = |\texttt{children}(T)|,\\
                                                                 \phantom{\text{Let }} q_1, r=\big\langle\lfloor\frac{i}{b}\rfloor, i \pmod{b}\big\rangle,\\
                                                                 \phantom{\text{Let }} lb, rb = \texttt{children}[r],\\
                                                                 \phantom{\text{Let }} T_1, q_2 = \varphi^{-1}(lb, q_1),\\
                                                                 \phantom{\text{Let }} T_2, q_3 = \varphi^{-1}(rb, q_2) \text{ in } \\
                                                                 \Big\langle\texttt{BTree}\big(\texttt{root}(T), T_1, T_2\big), q_3\Big\rangle & \text{otherwise.} \\
    \end{cases}
  \end{equation*}
\end{frame}

\begin{frame}[fragile]{Chomsky Denormalization}
  Chomksy normalization is needed for matrix-based parsing, however produces lopsided parse trees. We can denormalize them using a simple recusive procedure to restore the natural shape of the original CFG:\vspace{0.5cm}\\

  \begin{minipage}[l]{6cm}
    \vspace{0.3cm}\resizebox{\textwidth}{!}{
      \begin{tabular}{ll}
        \Tree [.\texttt{S} \tikz\node(v1){\texttt{true}} [.$\ccancel{\texttt{and.S}}$ \tikz\node(v3){\texttt{and}} [.\texttt{S} \tikz\node(v5){\texttt{(}} [.$\ccancel{\texttt{S.)}}$ [.\texttt{S} \tikz\node(v9){\texttt{false}} [.$\ccancel{\texttt{or.S}}$ \tikz\node(v11){\texttt{or}} [.\texttt{S} \texttt{!} \texttt{true} ] ] ] \tikz\node(v7){\texttt{)}} ] ] ] ]
%    \Tree [.S [.NP John ] [.VP [.\tikz\node(v1){V}; sleeps ] ] ]
        \hspace{-2cm}
        &
        \Tree [.\texttt{S} \tikz\node(v2){\texttt{true}} \tikz\node(v4){\texttt{and}} [.\texttt{S} \tikz\node(v6){\texttt{(}} [.\texttt{S} \tikz\node(v10){\texttt{false}} \tikz\node(v12){\texttt{or}} [.\texttt{S} \texttt{!} \texttt{true} ] ] \tikz\node(v8){\texttt{)}} ] ]\\\\
%    \Tree [.\tikz\node(v2){V}; [.\tikz\node(v3){V}; ] [.Adv {a lot} ] ]
        \hspace{1cm}\huge{Pre-Denormalization} & \hspace{3cm}\huge{Post-Denormalization}
      \end{tabular}
      \begin{tikzpicture}[overlay]
%    \draw [red,dashed,-stealth] (v1) to[bend left] (v2);
        \draw [red,dashed,-stealth] (v3) to[bend left] (v4);
%    \draw [red,dashed,-stealth] (v5) to[bend left] (v6);
        \draw [red,dashed,-stealth] (v7) to[bend left] (v8);
%    \draw [red,dashed,-stealth] (v9) to[bend right] (v10);
        \draw [red,dashed,-stealth] (v11) to[bend right] (v12);
      \end{tikzpicture}
    }
%    \caption{Result of applying Algorithm~\ref{alg:cap} to the tree obtained by parsing the string: \texttt{true and ( false or ! true )}.}
  \end{minipage}
  \hspace{-0.7cm}\scalebox{0.6}{
    \begin{minipage}[l]{10cm}
      \begin{algorithm}[H]
        \caption{Rewrite procedure for tree denormalization}\label{alg:cap}
        \begin{algorithmic}
          \Procedure{Cut}{\texttt{t: Tree}}
            \State $\texttt{stems} \leftarrow \{\:\textsc{Cut}(\texttt{c}) \mid \texttt{c} \in \texttt{t.children}\:\}$
            \If{$\texttt{t.root} \in (V_{\mathcal{G}'} \setminus V_{\mathcal{G}})$}
              \State \textbf{return } \texttt{stems} %\Comment{Drop synthetic nonterminals.}
            \Else%\Comment{Graft the denormalized children on root.}
              \State \textbf{return } $\{\:\texttt{Tree(t.root, stems)}\:\}$
            \EndIf
          \EndProcedure
        \end{algorithmic}
      \end{algorithm}
    \end{minipage}
  }

  \vspace{1cm}All synthetic nonterminals are excised during Chomsky denormalization. Rewriting improves legibility but does not alter the underlying semantics.
\end{frame}

%\begin{frame}{Error Recovery}
%  \begin{figure}[H]
%    \adjustbox{scale=0.75,center}{%
%    \hspace{-0.5cm}\begin{minipage}[l]{6cm}
%      \[
%        \begin{NiceMatrix}
%              \leftarrow & \nse & \nsi & \nfi & \nfo & \nth & \ntw & \non & \leftarrow & \ppp \\
%                         &      & \ddd & \ddd & \ddd & \ddd & \ddd & \ddd & \ddd & \ppp \\
%          \sigma_1^\shri & \cdd &      & A    &      &      &      &      &      & \ppp \\
%                    \vno & \ddd &  T_A & \vdd &      &      &      &      &      & \ppp \\
%                    \vdd & \ddd &      & \pcd & \cdd &      & B    &      &      & \ppp \\
%                         &      &      &      &      & T_B  & \vdd &      &      & \ppp \\
%                         &      &      &      &      &      & \pcd & \cdd &      & C    \\
%                         &      &      &      &      &      &      &      & T_C  & \vdd \\
%                         &      &      &      &      &      &      & \text{\emoji{cross-mark}} &      & \\
%                         &      &      &      &      &      &      &      &      & \\
%                         &      &      &      &      &      &      &      &      & \\
%                         &      &      &      &      &      &      &      & \ppp & \sigma_n^\shup \\
%                    \vno & \cdd &      &      &      &      &      &      & \vno &
%        \end{NiceMatrix}
%      \]
%    \end{minipage}
%    }
%    \hspace{1cm}
%
%    \caption{By recursing over upper diagonals of decreasing elevation and discarding subtrees that fall under the shadow of another's canopy, we can recover parseable subtrees.}
%  \end{figure}
%\end{frame}

\begin{frame}[fragile]{Error Correction: Sketch Templates}
  To sample $\bm{\sigma}\sim\Delta_{q}(\err{\sigma})$, we could enumerate a series of sketch templates $H(\sigma, i) = \sigma_{1\ldots i-1}\:\text{\texttt{\_} \texttt{\_}}\:\sigma_{i+1\ldots n}$ for each $i \in \cdot \in \stirlingii{n}{d}$ and $d \in 1\ldots q$, then solve for $\mathcal{M}_{\bm\sigma}^*$. If $S \in \Lambda^*_{\bm\sigma}?$ has a solution, each edit in each $\sigma' \in \bm\sigma$ will match exactly one of the following seven edit patterns:\vspace{-10pt}

  \begin{align*}
    \text{Deletion}&=\begin{cases}
                       \,\ldots\sigma_{i-1}\:\text{\hlred{$\gamma_1$}\:\hlred{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_{1, 2} = \varepsilon\label{eq:del}
    \end{cases}\\
    \text{Substitution}&=\begin{cases}
                           \ldots\sigma_{i-1}\:\text{\hlorange{$\gamma_1$}\:\hlred{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_1 \neq \varepsilon \land \gamma_2 = \varepsilon\\
                           \ldots\sigma_{i-1}\:\text{\hlred{$\gamma_1$}\:\hlorange{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_1 = \varepsilon \land \gamma_2 \neq \varepsilon\\
                           \ldots\sigma_{i-1}\:\text{\hlorange{$\gamma_1$}\:\hlorange{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\{\gamma_1, \gamma_2\}\cap\{\varepsilon, \sigma_i\} = \varnothing
    \end{cases}\\
    \text{Insertion}&=\begin{cases}
                        \ldots\sigma_{i-1}\:\text{\hlgreen{$\gamma_1$}\:\hlorange{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_1 = \sigma_i \land \gamma_2 \notin \{\varepsilon,  \sigma_i\}\label{eq:ins2}\\
                        \ldots\sigma_{i-1}\:\text{\hlorange{$\gamma_1$}\:\hlgreen{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_1 \notin \{\varepsilon, \sigma_i\} \land \gamma_2 = \sigma_i\label{eq:ins1}\\
                        \ldots\sigma_{i-1}\:\text{\hlgreen{$\gamma_1$}\:\hlgreen{$\gamma_2$}}\:\sigma_{i+1}\ldots\hspace{0.2cm}\gamma_{1,2} = \sigma_i\label{eq:copy}
    \end{cases}
  \end{align*}

  But this is very expensive, requiring $\widetilde{\mathcal O}\left({n \choose d}|\Sigma + 1|^{2d}\right)$ to search $\stirlingii{n}{d}\times\Sigma_\varepsilon^{2d}$.
\end{frame}

\begin{frame}[fragile]{Error Correction: d-Subset Sampling}
  \noindent Next, suppose $U: \mathbb{Z}_2^{m\times m}$ is a matrix whose structure is shown in Eq.~\ref{eq:lfsr}, wherein $C$ is a primitive polynomial over $\mathbb{Z}_2^m$ with coefficients $C_{1\ldots m}$ and semiring operators $\oplus := \veebar, \otimes := \land$:\vspace{-5pt}

  \begin{align}
    U^tV = \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
             C_1    & \cdd  &       &       & C_m \\
             \top   & \circ & \cdd  &       & \circ \\
             \circ  & \ddd  & \ddd  &       & \vdd \\
             \vdd   & \ddd  &       &       & \\
             \circ  & \cdd  & \circ & \top  & \circ
    \end{pNiceMatrix}^t
    \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
      V_1 \\
      \vdd\\
      \\
      \\
      V_m
    \end{pNiceMatrix}\label{eq:lfsr}
  \end{align}

  \noindent Since $C$ is primitive, the sequence $\mathbf{S} = (U^{0 \ldots 2^m-1}V)$ must have \textit{full periodicity}, i.e., for all $i, j \in[0, 2^m)$, ${\mathbf{S}_i = \mathbf{S}_j \Rightarrow i = j}$. To uniformly sample $\bm\sigma$ without replacement, we first form an injection $\mathbb{Z}_2^m\rightharpoonup\stirlingii{n}{d}\times\Sigma_\varepsilon^{2d}$ using a combinatorial number system, cycle over $\mathbf{S}$, then discard samples which have no witness in $\stirlingii{n}{d}\times\Sigma_\varepsilon^{2d}$. This method requires $\widetilde{\mathcal O}(1)$ per sample and $\widetilde{\mathcal O}\left({n \choose d}|\Sigma + 1|^{2d}\right)$ to exhaustively search $\stirlingii{n}{d}\times\Sigma_\varepsilon^{2d}$.
\end{frame}

\begin{frame}[fragile]{Levenshtein reachability and monotone infinite automata}
  \begin{figure}[H]
    \begin{minipage}[c]{0.5\textwidth}
      \centering
      \underline{MAIA}\vspace{10pt}
      \resizebox{\textwidth}{!}{
      \begin{tikzpicture}[
%->, % makes the edges directed
        >=stealth',
        node distance=2.5cm, % specifies the minimum distance between two nodes. Change if necessary.
%  every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
        initial text=$ $, % sets the text that appears on the start arrow
      ]
        \node[state, initial]                (00) {$q_{0,0}$};
        \node[state, right of=00]            (10) {$q_{1,0}$};
        \node[state, right of=10]            (20) {$q_{2,0}$};
        \node[state, right of=20]            (30) {$q_{3,0}$};
        \node[right of=30]                   (40) {$\vphantom{\vdots}\cdots$};
        \node[accepting, state, right of=40] (n0) {$q_{n,0}$};

        \node[state, above of=00]            (01) {$q_{0,1}$};
        \node[state, right of=01]            (11) {$q_{1,1}$};
        \node[state, right of=11]            (21) {$q_{2,1}$};
        \node[state, right of=21]            (31) {$q_{3,1}$};
        \node[right of=31]                   (41) {$\vphantom{\vdots}\cdots$};
        \node[accepting, state, right of=41] (n1) {$q_{n,1}$};

        \node[above of=01]                   (0j) {$\mathmakebox[\widthof{$\cdots$}]{\vdots}$};
\node[right of=0j]                   (1j) {$\mathmakebox[\widthof{$\cdots$}]{\vdots}$};
\node[right of=1j]                   (2j) {$\mathmakebox[\widthof{$\cdots$}]{\vdots}$};
\node[right of=2j]                   (3j) {$\mathmakebox[\widthof{$\cdots$}]{\vdots}$};
\node[right of=3j]                   (4j) {$\iddots$};
\node[accepting, right of=4j]        (nj) {$\mathmakebox[\widthof{$\cdots$}]{\vdots}$};

\node[state, above of=0j]            (0k) {$q_{0,k}$};
\node[state, right of=0k]            (1k) {$q_{1,k}$};
\node[state, right of=1k]            (2k) {$q_{2,k}$};
\node[state, right of=2k]            (3k) {$q_{3,k}$};
\node[right of=3k]                   (4k) {$\vphantom{\vdots}\cdots$};
\node[accepting, state, right of=4k] (nk) {$q_{n,k}$};

\draw [->] (00) edge[below] node{$\sigma_1$} (10);
\draw [->] (10) edge[below] node{$\sigma_2$} (20);
\draw [->] (20) edge[below] node{$\sigma_3$} (30);
\draw [->] (30) edge[below] node{$\sigma_4$} (40);
\draw [->] (40) edge[below] node{$\sigma_n$} (n0);

\draw [->] (01) edge[below] node{$\sigma_1$} (11);
\draw [->] (11) edge[below] node{$\sigma_2$} (21);
\draw [->] (21) edge[below] node{$\sigma_3$} (31);
\draw [->] (31) edge[below] node{$\sigma_4$} (41);
\draw [->] (41) edge[below] node{$\sigma_n$} (n1);

\draw [->] (0j) edge[below] node{$\sigma_1$} (1j);
\draw [->] (1j) edge[below] node{$\sigma_2$} (2j);
\draw [->] (2j) edge[below] node{$\sigma_3$} (3j);
\draw [->] (3j) edge[below] node{$\sigma_4$} (4j);
\draw [->] (4j) edge[below] node{$\sigma_n$} (nj);

\draw [->] (0k) edge[below] node{$\sigma_1$} (1k);
\draw [->] (1k) edge[below] node{$\sigma_2$} (2k);
\draw [->] (2k) edge[below] node{$\sigma_3$} (3k);
\draw [->] (3k) edge[below] node{$\sigma_4$} (4k);
\draw [->] (4k) edge[below] node{$\sigma_n$} (nk);

\draw [->] (00) edge[left] node{$*$}         (11);
\draw [->] (10) edge[left] node{$*$}         (21);
\draw [->] (20) edge[left] node{$*$}         (31);
\draw [->] (30) edge[left] node{$*$}         (41);
\draw [->] (30) edge[bend right, below] node{$\sigma_5$} (41);
\draw [->] (40) edge[           right] node{$\sigma_n$}  (n1);
\draw [->] (40) edge[bend right, left] node{$*$}         (n1);

\draw [->] (01) edge[left] node{$*$}                     (1j);
\draw [->] (11) edge[left] node{$*$}                     (2j);
\draw [->] (21) edge[left] node{$*$}                     (3j);
\draw [->] (31) edge[left] node{$*$}                     (4j);
\draw [->] (31) edge[bend right, below] node{$\sigma_5$} (4j);
\draw [->] (41) edge[           right] node{$\sigma_n$}  (nj);
\draw [->] (41) edge[bend right, left] node{$*$}         (nj);

\draw [->] (0j) edge[left] node{$*$}                     (1k);
\draw [->] (1j) edge[left] node{$*$}                     (2k);
\draw [->] (2j) edge[left] node{$*$}                     (3k);
\draw [->] (3j) edge[left] node{$*$}                     (4k);
\draw [->] (3j) edge[bend right, below] node{$\sigma_5$} (4k);
\draw [->] (4j) edge[           right] node{$\sigma_n$}  (nk);
\draw [->] (4j) edge[bend right, left] node{$*$}         (nk);

\draw [->] (00) edge[bend left, left] node{$*$}   (01);
\draw [->] (10) edge[bend left, left] node{$*$}   (11);
\draw [->] (20) edge[bend left, left] node{$*$}   (21);
\draw [->] (30) edge[bend left, left] node{$*$}   (31);
\draw [->] (40) edge[right] node{$*$}             (41);
\draw [->] (n0) edge[bend right, right] node{$*$} (n1);

\draw [->] (01) edge[bend left, left] node{$*$}   (0j);
\draw [->] (11) edge[bend left, left] node{$*$}   (1j);
\draw [->] (21) edge[bend left, left] node{$*$}   (2j);
\draw [->] (31) edge[bend left, left] node{$*$}   (3j);
\draw [->] (41) edge[right] node{$*$}             (4j);
\draw [->] (n1) edge[bend right, right] node{$*$} (nj);

\draw [->] (0j) edge[bend left, left] node{$*$}   (0k);
\draw [->] (1j) edge[bend left, left] node{$*$}   (1k);
\draw [->] (2j) edge[bend left, left] node{$*$}   (2k);
\draw [->] (3j) edge[bend left, left] node{$*$}   (3k);
\draw [->] (4j) edge[right] node{$*$}             (4k);
\draw [->] (nj) edge[bend right, right] node{$*$} (nk);

\draw [->] (00) edge[below] node{$\sigma_2$}    (21);
\draw [->] (10) edge[below] node{$\sigma_3$}    (31);
\draw [->] (20) edge[below] node{$\sigma_4$}    (41);

\draw [->] (01) edge[below] node{$\sigma_2$}    (2j);
\draw [->] (11) edge[below] node{$\sigma_3$}    (3j);
\draw [->] (21) edge[below] node{$\sigma_4$}    (4j);

\draw [->] (0j) edge[below] node{$\sigma_2$}    (2k);
\draw [->] (1j) edge[below] node{$\sigma_3$}    (3k);
\draw [->] (2j) edge[below] node{$\sigma_4$}    (4k);

%https://tex.stackexchange.com/a/20986/139648
\draw [decorate,decoration={brace,amplitude=10pt,raise=10pt,mirror}] (00.south west) -- (n0.south east) node[midway,yshift=-3em]{\textbf{String length}};
\draw [decorate,decoration={brace,amplitude=10pt,raise=20pt}] (00.south west) -- (0k.north west) node[midway,xshift=-40pt,rotate=90]{\textbf{Levenshtein edit distance}};
\end{tikzpicture}
}
\end{minipage}
\hfill
\begin{minipage}[l]{5 cm}
\centering
\underline{CFG}\vspace{14.5pt}
{\footnotesize
\begin{align*}
S &\Rightarrow \{\cdot \in Q \mid \delta(\cdot, q_{n,0}) \leq k\}\\
* &\Rightarrow \{\cdot \in \Sigma\}\\
\big\{q_{i, j} &\Rightarrow \{q_{i, j-1}*\} \mid i, j \in [1, n]\times[1, k]\big\}\\
\big\{q_{i, j} &\Rightarrow \{q_{i-1, j-1}*\}\mid i, j\in[1, n]\times [1, k]\big\}\\
\big\{q_{i, j} &\Rightarrow \{q_{i-1, j} \sigma_i \}\mid i, j \in [1, n]\times[0, k]\big\} \\
\big\{q_{i, j} &\Rightarrow \{q_{i-2, j-1} \sigma_i\} \mid i, j \in [2, n]\times[1, k] \big\}\\
\end{align*}
}%
\end{minipage}
\caption{Bounded Levenshtein reachability from $\sigma: \Sigma^n$ is expressible as either a monotone acyclic infinite automata (MAIA) populated by accept states within radius $k$ of $S=q_{n,0}$ (left), or equivalently, a left-linear CFG whose productions bisimulate the transition dynamics up to a fixed horizon (right), accepting only strings within Levenshtein radius $k$ of $\sigma$.}
\end{figure}
\end{frame}

\begin{frame}[fragile]{The Chomsky-Levenshtein-Bar-Hillel Construction}
The original Bar-Hillel construction provides a way to construct a grammar for the intersection of a regular and context-free langauge.
\noindent\begin{prooftree}
\AxiomC{$q \in I \phantom{\land} r \in F\vphantom{\overset{a}{\rightarrow}}$}
%  \RightLabel{$\varepsilon^+\textsc{-int}$}
\UnaryInfC{$\big(S\rightarrow q S r\big) \in P_\cap$}
\DisplayProof
\hskip 0.5em
\AxiomC{$(q\overset{a}{\rightarrow}r) \in \delta$}
%  \RightLabel{$\varepsilon^+\textsc{-int}$}
\UnaryInfC{$\big(qar\rightarrow a\big)\in P_\cap$}
\DisplayProof
\hskip 0.5em
%\end{prooftree}
%\begin{prooftree}
\AxiomC{$(w \rightarrow xz) \in P\vphantom{\overset{a}{\rightarrow}}$}
\AxiomC{$p,q,r \in Q$}
\BinaryInfC{$\big(pwr\rightarrow (pxq)(qzr)\big) \in P_\cap$}
\end{prooftree}

The Levenshtein automata is another kind of lattice, not in the order-theoretic sense, but in the automata-theoretic sense.

\begin{prooftree}
\AxiomC{$s\in\Sigma \phantom{\land} i \in [0, n] \phantom{\land} j \in [1, k]$}
\RightLabel{$\duparrow$}
\UnaryInfC{$(q_{i, j-1} \overset{s}{\rightarrow} q_{i,j}) \in \delta$}
\DisplayProof
\hskip 1.5em
\AxiomC{$s\in\Sigma \phantom{\land} i \in [1, n] \phantom{\land} j \in [1, k]$}
\RightLabel{$\ddiagarrow$}
\UnaryInfC{$(q_{i-1, j-1} \overset{s}{\rightarrow} q_{i,j}) \in \delta$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$s=\sigma_i \phantom{\land} i \in [1, n] \phantom{\land} j \in [0, k]$}
\RightLabel{$\drightarrow$}
\UnaryInfC{$(q_{i-1, j} \overset{s}{\rightarrow} q_{i,j}) \in \delta$}
\DisplayProof
\hskip 1.5em
\AxiomC{$s=\sigma_i \phantom{\land} i \in [2, n] \phantom{\land} j \in [1, k]$}
\RightLabel{$\knightarrow$}
\UnaryInfC{$(q_{i-2, j-1} \overset{s}{\rightarrow} q_{i,j}) \in \delta$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$\vphantom{|}$}
\RightLabel{$\textsc{Init}$}
\UnaryInfC{$q_{0,0} \in I$}
\DisplayProof
\hskip 1.5em
\AxiomC{$q_{i, j}$}
\AxiomC{$|n-i+j| \leq k$}
\RightLabel{$\textsc{Done}$}
\BinaryInfC{$q_{i, j}\in F$}
\end{prooftree}
\end{frame}

\section{Error Correction}\label{sec:error-correction}

%\begin{frame}[fragile]{Sampling without replacement}
%Let $A$ be a complicated space we do not know how to sample from.
%\begin{figure}
%\centering
%\begin{tikzpicture}[ele/.style={fill=black,circle,minimum width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,minimum width=5pt,inner sep=10pt}]
%\node[ele,label=left:$a$] (a1) at (0,3) {};
%\node[ele,label=left:$b$] (a2) at (0,2) {};
%\node[ele,label=left:$c$] (a3) at (0,1) {};
%%\node[ele,label=left:$d$] (a4) at (0,1) {};
%
%\node[ele,,label=right:$1$] (b1) at (4,4) {};
%\node[ele,,label=right:$2$] (b2) at (4,3) {};
%\node[ele,,label=right:$3$] (b3) at (4,2) {};
%\node[ele,,label=right:$4$] (b4) at (4,1) {};
%
%\node[draw,fit= (a1) (a2) (a3),minimum width=2.5cm,label=below:$A$] {} ;
%\node[draw,fit= (b1) (b2) (b3) (b4),minimum width=2.5cm,label=below:$\mathbb{N}$] {} ;
%\draw[->,shorten <=2pt,shorten >=2pt] (a1) -- (b4);
%\draw[->,shorten <=2pt,shorten >=2] (a2) -- (b2);
%\draw[->,shorten <=2pt,shorten >=2] (a3) -- (b1);
%%\draw[->,shorten <=2pt,shorten >=2] (a4) -- (b3);
%\end{tikzpicture}
%\end{figure}
%We want a permutation mapping $f: A \rightarrow \mathbb{N} \mid \forall a \in A \exists i \in \mathbb{N}.f^{-1}(i) = a$. Then we can just sample $i \sim \mathbb{N}$ without replacement and apply $f^{-1}(i)$.
%\end{frame}


\begin{frame}{Abbreviated history of algebraic parsing}
\begin{itemize}
\item \href{http://www-igm.univ-mlv.fr/~berstel/Mps/Travaux/A/1963-7ChomskyAlgebraic.pdf}{Chomsky \& Sch\"utzenberger (1959) - The algebraic theory of CFLs}
\item Cocke–Younger–Kasami (1961) - Bottom-up matrix-based parsing
\item \href{https://dl.acm.org/doi/10.1145/321239.321249}{Brzozowski (1964) - Derivatives of regular expressions}
\item \href{https://dl.acm.org/doi/10.1145/362007.362035}{Earley (1968) - top-down dynamic programming (no CNF needed)}
\item \href{http://theory.stanford.edu/~virgi/cs367/papers/valiantcfg.pdf}{Valiant (1975) - first realizes the Boolean matrix correspondence}
\begin{itemize}
\item Na\"ively, has complexity $\mathcal{O}(n^4)$, can be reduced to $\mathcal{O}(n^\omega)$, $\omega < 2.763$
\end{itemize}
\item \href{https://www.cs.cornell.edu/home/llee/papers/bmmcfl-jacm.pdf}{Lee (1997) - Fast CFG Parsing $\Longleftrightarrow$ Fast BMM, formalizes reduction}
\item \href{https://matt.might.net/papers/might2011derivatives.pdf}{Might et al. (2011) - Parsing with derivatives (Brzozowski $\Rightarrow$ CFL)}
\item \href{https://users.math-cs.spbu.ru/~okhotin/papers/formal_languages_gf2.pdf}{Bakinova, Okhotin et al. (2010) - Formal languages over GF(2)}
\item \href{https://arxiv.org/pdf/1601.07724.pdf}{Bernady \& Jansson (2015) - Certifies Valiant (1975) in Agda}
\item \href{https://arxiv.org/pdf/1504.08342.pdf}{Cohen \& Gildea (2016) - Generalizes Valiant (1975) to parse and recognize mildly context sensitive languages, e.g. LCFRS, TAG, CCG}
\item Considine, Guo \& Si (2022) - SAT + Valiant (1975) + holes
\item \textbf{Considine (2023) - $\mathbb{T}_3$ completion + distinct tree sampling}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Uniform sampling benchmark on natural syntax errors}
\begin{figure}[H]
\resizebox{.3\textwidth}{!}{\input{repair1-3_plot.tex}}
\resizebox{.3\textwidth}{!}{\input{repair1_plot.tex}}
\resizebox{.3\textwidth}{!}{\input{repair2_plot.tex}}
%\resizebox{.3\textwidth}{!}{\input{repair1_plot.tex}}
%\resizebox{.307\textwidth}{!}{\input{repair2_plot.tex}}
\caption{Repairs discovered before the latency cutoff are reranked based on their tokenwise perplexity and compared for an exact lexical match with the human repair at or below rank k. We note that the uniform sampling procedure is not intended to be used in practice, but provides a baseline for the empirical density of the admissible set, and an upper bound on the latency required to attain a given precision.}\label{fig:human}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Adaptive sampling benchmark on natural syntax errors}
\begin{figure}[H]
\resizebox{.24\textwidth}{!}{\input{repair1-3_10s_plot.tex}}
\resizebox{.25\textwidth}{!}{\input{repair1_10s_plot.tex}}
\resizebox{.24\textwidth}{!}{\input{repair2_10s_plot.tex}}
\resizebox{.24\textwidth}{!}{\input{repair3_10s_plot.tex}}
\caption{Adaptive sampling repairs. The red line indicates Seq2Parse precision@1 on the same dataset. Since it only supports generating one repair, we do not report precision@k or the intermediate latency cutoffs.}\label{fig:adaptive}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Multicore Scaling Results (aarch64)}
\begin{tikzpicture}
\begin{axis}[
ybar,
enlargelimits=0.15,
legend style={at={(0.03,0.97)},anchor=north west},
title={\textbf{Relative Total Distinct Solutions Found vs. Single Core}},
x=1cm,
ylabel={Relative improvement},
xlabel={Number of assigned cores},
symbolic x coords={2,3,4,5,6,7,8,9,10},
xtick=data,
bar width=3pt,
]
\addplot coordinates {
(2,0.1343) (3,0.1955) (4,0.2249) (5,0.2475)
(6,0.2760) (7,0.2994) (8,0.3073) (9,0.3151) (10,0.3229)
};
\addplot coordinates {
(2,0.2655) (3,0.4353) (4,0.5614) (5,0.6644)
(6,0.7462) (7,0.7783) (8,0.8347) (9,0.8005) (10,0.7798)
};
\addplot coordinates {
(2,0.3972) (3,0.6928) (4,0.9327) (5,1.1834)
(6,1.3138) (7,1.3988) (8,1.6039) (9,1.5500) (10,1.5691)
};
\addplot coordinates {
(2,0.4863) (3,0.8326) (4,1.1368) (5,1.3879)
(6,1.5873) (7,1.7494) (8,1.8802) (9,1.9059) (10,1.9625)
};
\addplot coordinates {
(2,0.4315) (3,0.7583) (4,1.0122) (5,1.2593)
(6,1.4586) (7,1.6349) (8,1.7813) (9,1.8324) (10,1.8695)
};
\legend{Holes=2,Holes=3,Holes=4,Holes=5,Holes=6}
\end{axis}
\end{tikzpicture}
\end{frame}

\begin{frame}{Special thanks}
  \begin{center}
    \LARGE{
      David Bieber, David Yu-Tung Hui\\
      Shawn Tan, Jin Guo, Xujie Si\\
      \phantom{}\\
    }
    \href{https://cs.mcgill.ca}{\includegraphics[scale=0.06]{../../figures/mcgill_logo.png}}
    \href{https://mila.quebec}{\includegraphics[scale=0.1]{../../figures/mila_logo.png}}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \huge{Learn more at: \\~\\
    \href{https://tidyparse.github.io}{\color{blue}{https://tidyparse.github.io}}}\\~\\
    \qrcode[height=1.7in]{https://tidyparse.github.io/}
  \end{center}
\end{frame}
\end{document}