LAFI 2026 Paper #43 Reviews and Comments
===========================================================================
Paper #43 A Word Sampler for Well-Typed Functions


Review #43A
===========================================================================

Overall merit
-------------
2. Accept

Reviewer expertise
------------------
2. Some familiarity

Comments for authors
--------------------
This abstract shows how to (1) construct a CFG of exactly the well-typed expressions in a simply-typed lambda calculus, (2) intersect that CFG with a regular language, and (3) [assuming the intersection is finite] sample uniformly from the intersection (or, presumably, non-uniformly, e.g. to perform constrained decoding from a language model). A small experiment uses the technique to generate uniformly from the set of well-typed, length-$n$ functions of various arities, and to perform type inference (by intersecting the CFG with a regular language that contains differently type-annotated definitions of a given function). Compilation appears to incur some latency, but once compiled, hundreds of thousands of samples can be drawn per second.

I enjoyed reading this abstract, but could have used a bit more motivation. I found myself wondering:
- what sorts of problems require this functionality?
- what are the existing solutions, and why might this one be preferable?
- what sorts of intersections do you imagine users taking in practice? would users typically be aiming to sample uniformly, or from a biased distribution?



Review #43B
===========================================================================

Overall merit
-------------
2. Accept

Reviewer expertise
------------------
3. Knowledgeable

Comments for authors
--------------------
The paper proposes a method to sample a random function uniformly at without replacement from well-typed functions in a language of expressions generated by an acyclic finite automation.

The paper is generally hard to read.

It would be good to explain that $\mathcal{L}(\alpha_\varnothing)$ is guaranteed to be finite, and to explain why the simply-typed language admits a finite number of programs.

The symbols $\mathbb{N}$ and $\mathbb{B}$ are overloaded in the term language (as syntactic categories) and in the type languages (as terminal tokens that denote base types). Please use a different symbol to avoid confusion. For example, in `PRM`,  the rule PID : $\mathbb{T}$ is intended to expand to something like PID : $\mathbb{B}$; but the grammar as-written permits further expansion of the base type $\mathbb{B}$ into $\texttt{true}$ yielding PID : $\texttt{true}$.

In the rule for $\mathbb{T}$, what is $\tau^{(d)}$?, are these homogenous product types?

In the rule for FID, is the `n` in `fn` supposed to be replaced with a fixed constant such, e.g., `f59`?

In the rule of $\Gamma$ what is `f_`?, is it supposed to be `f0` ... `fn`?

What are the applications of this problem to probabilistic programming? See Saad et al. (POPL 2019) for one possible application, where the authors use a PCFG prior over expressions that parameterize probabilistic models within a program synthesis framework. Could your method be used in such contexts?



Review #43C
===========================================================================

Overall merit
-------------
1. Reject

Reviewer expertise
------------------
2. Some familiarity

Comments for authors
--------------------
This paper describes an exact sampler for a simply-typed, first-order functional programming language that produces uniform samples without replacement via a fixed-parameter tractable reduction from a syntax-directed type system to a context-free grammar.

The abstract clearly describes the technical method for achieving uniform sampling of a simply-typed, first-order functional programming language. However, it does not sufficiently motivate why such uniform sampling is of interest in the context of the workshopâ€™s focus on languages for inference.

While I am convinced that the method itself has merit and could have applications concerning inference for programming languages, its relevance to the broader audience of LAFI remains unclear to me. For this reason, I lean toward rejection.



Comment @A1 by Reviewer A
---------------------------------------------------------------------------
Additional comment by PC chairs:

Thank you for your submission! Reviewers agreed that the work itself seems to have merit, but could not see the intended connection to the LAFI audience. We have decided to accept the abstract, but for the presentation, we request that you please address this concern. In particular, please give a better sense of the motivation for this work, and how it might connect to applications in probabilistic or differentiable programming. We look forward to discussing at the workshop!