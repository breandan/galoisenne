%! Author = breandan
%! Date = 11/5/25

\documentclass{beamer}

% Basic fonts & symbols
\usepackage[T1]{fontenc}
\usepackage{tgcursor}
\usepackage{booktabs}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}} % ✓
\newcommand{\xmark}{\ding{55}} % ✗
%\usepackage[mathrm=sym]{unicode-math}
\usepackage{multicol}
\usepackage[table]{xcolor}

\usepackage{tikz-cd}
\usepackage{adjustbox}

\usepackage{txfonts}
\usepackage{soul}
\usepackage{mathtools}

\usepackage[normalem]{ulem}
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing,calc,automata,arrows}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\definecolor{Light}{gray}{.90}
\sethlcolor{Light}

\newcommand{\codett}[1]{\texttt{\hl{#1}}}
\DeclareMathOperator*{\largecomma}{\mathop{\vcenter{\hbox{\Huge\texttt{,}}}}}
\newcommand{\bycommas}{%
  \mathop{\vphantom{\sum}\mathchoice{\Large ,}{,}{,}{,}}\displaylimits
}
\newcommand{\cev}[1]{\reflectbox{\ensuremath{\vec{\reflectbox{\ensuremath{#1}}}}}}
\newcommand\hmmax{0}
\newcommand\bmmax{0}
\usepackage{amssymb}
\usepackage{centernot}
\usepackage{bussproofs}
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\SetMathAlphabet{\mathcal}{bold}{OMS}{cmsy}{b}{n}

\newcommand{\nt}[1]{\texttt{#1}}      % nonterminals
\newcommand{\tok}[1]{\codett{#1}}     % terminals
\newcommand{\gap}{\;\;}
\newcommand{\cjoin}[2]{\mathop{\largecomma}\limits_{#1}^{#2}}

\newcommand{\bs}{\blacksquare}
\newcommand{\ws}{\square}

\newcommand{\T}{\mathbb{T}}
\newcommand{\ttlb}{\{}   % left brace token
\newcommand{\ttrb}{\}}   % right brace token
\newcommand{\ttus}{\_}   % underscore token (for f_*)

% Metadata
\title{A Word Sampler for Well-Typed Functions}
\author{Breandan Mark Considine}
\date{\today}

\begin{document}

% -------------------------------------------------
\begin{frame}
  \titlepage
\end{frame}
% -------------------------------------------------

\begin{frame}{Formal langauges \& type theory}
  \vspace{-0.3cm}
    \[
      \underbrace{\sigma \in \mathcal{L}(G) \Leftrightarrow  \exists V.\ V \Rightarrow_G^{\!*} \sigma}_{\text{membership / parse tree}}
      \qquad\leftrightsquigarrow\qquad
      \underbrace{\exists \tau .\ (\Gamma \vdash e : \tau)}_{\text{type checking / proof tree}}
    \]
\vspace{0.2cm}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash x : X$}
      \AxiomC{$\Gamma \vdash z : Z$}
      \LeftLabel{$\smash{\underbrace{(W\rightarrow X Z)\in P}_{\text{grammar production}}}\hspace{0.8cm}\leftrightsquigarrow\hspace{1cm}$}
      \BinaryInfC{$\underbrace{\hspace{1cm}\Gamma \vdash xz: W\hspace{1cm}}_{\text{typing judgment}}$}
    \end{prooftree}

    \[
      \underbrace{\mathcal{L}(G) \neq \varnothing \Leftrightarrow \exists \sigma.\ S \Rightarrow_G^{\!*} \sigma}_{\text{non-emptiness / generation}}
      \qquad\leftrightsquigarrow\qquad
      \underbrace{\exists e .\ (\Gamma \vdash e : \tau)}_{\text{type inhabitation / synthesis}}
    \]

  \vspace{0.3cm}
      \textbf{Goal}: Given a set of typing judgements and a typing context ($\Gamma$), design a grammar, $G$, s.t. $\forall \sigma\in\Sigma^{<n} \exists \tau\ .\ \sigma \in \mathcal{L}(G)\Longleftrightarrow\Gamma\vdash\sigma:\tau$.
\end{frame}


\begin{frame}{Programming language [in]approximability}
  \begin{columns}[T,onlytextwidth]
    \hspace{-0.5cm}\begin{column}{0.5\textwidth}
         \begin{itemize}
           \item<1-> $\Sigma^*$: all words over $\Sigma$
           \item<2-> $\mathcal{L}(G)$: syntactically valid
           \item<3-> Most LLMs: $\sigma \leftsquigarrow \Sigma^*$
           \item<4-> Guidance: $\sigma \leftsquigarrow \mathcal{L}(G)$
           \only<5->{\item $\mathcal{L}(\downarrow)$: halting programs}
           \item<6-> Tighter approximations require ever-increasing expressive power
           \item<7-> $\mathcal{L}(\Gamma)$: type-safe programs
           \item<8-> Typesafe: $\sigma \leftsquigarrow \mathcal{L}(\Gamma)$
         \end{itemize}
    \end{column}

    \begin{column}{0.5\textwidth}
      \centering
      \hspace{-0.3cm}\begin{tikzpicture}[scale=0.94, >=latex]
       %-----------------------------
       % Universe: Σ^* (square)
       %-----------------------------
       \coordinate (C) at (3,3);

       \only<1->{
         \draw[thick] (0,0) rectangle (6,6);
         \node at ($(C)+(-2.5,2.5)$) {$\Sigma^*$};
       }

      %----------------------------------------
      % Slide 3: LLM splatter over Σ* (square only)
      %----------------------------------------
       \only<3>{
         \pgfmathsetseed{20260111}

         \def\muX{3}
         \def\muY{3}
         \def\sigma{1.05}

         \begin{scope}
           \clip (0,0) rectangle (6,6); % ONLY square cutoff

           \foreach \k in {1,...,460}{
             % Box–Muller for 2D normal
             \pgfmathsetmacro{\u}{max(rnd,1e-6)}
             \pgfmathsetmacro{\r}{sqrt(-2*ln(\u))}
             \pgfmathsetmacro{\t}{360*rnd}

             \pgfmathsetmacro{\x}{\muX + \sigma*\r*cos(\t)}
             \pgfmathsetmacro{\y}{\muY + \sigma*\r*sin(\t)}

             \fill[red] (\x,\y) circle[radius=0.032];
           }
         \end{scope}
       }

       %----------------------------------------
       % Slide 4: Guidance = delete samples outside L(G)
       %----------------------------------------
       \only<4>{
         \pgfmathsetseed{20260111}

         \def\muX{3}
         \def\muY{3}
         \def\sigma{1.05}

         \begin{scope}
           \clip (0,0) rectangle (6,6);
           \clip (C) circle[radius=2.45]; % inside the wavy L(G) boundary (2.6)

           \foreach \k in {1,...,360}{
             \pgfmathsetmacro{\u}{max(rnd,1e-6)}
             \pgfmathsetmacro{\r}{sqrt(-2*ln(\u))}
             \pgfmathsetmacro{\t}{360*rnd}

             \pgfmathsetmacro{\x}{\muX + \sigma*\r*cos(\t)}
             \pgfmathsetmacro{\y}{\muY + \sigma*\r*sin(\t)}

             \fill[red] (\x,\y) circle[radius=0.032];
           }
         \end{scope}
       }

       %-----------------------------
       % Outer curve: L(G) (slightly wavy)
       %-----------------------------
       \only<2->{
         \pgfmathsetseed{12310}
         \begin{scope}[decoration={random steps,segment length=2pt,amplitude=1.02pt}]
           \draw[thick,decorate] (C) circle [radius=2.6];
         \end{scope}
         \node at ($(C)+(-1.5,1.5)$) {$\mathcal{L}(G)$};
       }

       %-----------------------------
       % Middle curve: L(Γ) (jagged)
       %-----------------------------
       \only<7->{
         \begin{scope}[decoration={random steps,segment length=4pt,amplitude=4pt}]
           \draw[thick,decorate] (C) circle [radius=1.65];
         \end{scope}
         \node at ($(C)+(-0.87,0.87)$) {$\mathcal{L}(\Gamma)$};
       }

       %-----------------------------
       % Inner curve: L(⇓) (very jagged) -- slide 4 only
       %-----------------------------
       \only<5-7>{
         \pgfmathsetseed{11313}
         \begin{scope}[decoration={random steps,segment length=0.6pt,amplitude=5pt}]
           \draw[thick,decorate,black!50] (C) circle [radius=0.7];
         \end{scope}
         \node at (C) {$\mathcal{L}(\downarrow)$};
       }

       %-----------------------------
       % Slide 5: spray sparse uniform samples inside L(Γ)
       % (remove innermost jagged circle by not showing it on <5>)
       %-----------------------------
       \only<8->{
       % keep dots comfortably inside the jagged boundary
         \pgfmathsetseed{20260101}
         \begin{scope}
           \clip (C) circle[radius=1.45];
           \foreach \k in {1,...,80}{
             \pgfmathsetmacro{\rr}{sqrt(rnd)*1.45}
             \pgfmathsetmacro{\tt}{rnd*360}
             \fill[red] ($(C)+(\tt:\rr)$) circle[radius=0.032];
           }
         \end{scope}
       }
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Stratified sampling with finite model theory}
  \begin{columns}[T,onlytextwidth]
    %-------------------- LEFT: bullets --------------------
    \hspace{-0.5cm}
    \begin{column}{0.5\textwidth}
      \vspace{0.6cm}
      \begin{itemize}
        \item But $\mathcal{L}(\Gamma)$ is infinite
        \item Consider finite models
        \item Isolate key complexity parameters of interest
        \item Embed description into a context-free grammar
        \item Disintegrate into fixed-\\parameter tractable slices
        \item Sample uniformly from the exact conditional distribution
      \end{itemize}
    \end{column}

    %-------------------- RIGHT: figure --------------------
    \begin{column}{0.5\textwidth}
      \vspace{-0.5cm}
      \hspace{-3cm}
      \hfill % push to the right edge of the column
      \begin{tikzpicture}
        \begin{axis}[
          view={25}{14},
          width=9.2cm,
          height=10cm,
          xmin=-10, xmax=10,
          ymin=-10, ymax=10,
          zmin=0, zmax=8,
          hide axis,
          grid=none,
        ]

          % Paraboloid z = r^2 up to z=8
          \pgfmathsetmacro\R{sqrt(8)}
          \addplot3[
          surf,
          shader=interp,
          opacity=0.3,
          colormap/viridis,
          domain=0:360,
          y domain=0:\R,
          samples=55,
          samples y=25
          ] ({y*cos(x)}, {y*sin(x)}, {y^2});

          % Draw jagged level sets at z = 1,3,5,7
          \pgfmathsetseed{12310}
          \foreach \z [count=\i] in {1,3,5,7}{
            % Inner jagged circle
            \pgfmathsetmacro\rinner{sqrt(\z/0.9)}
            \def\innerpoints{}
            \foreach \sample in {1,...,20}{
              \pgfmathsetmacro\ang{360*\sample/20}
              \pgfmathsetmacro\noise{0.4 * rand}
              \pgfmathsetmacro\x{ (\rinner + \noise) * cos(\ang) }
              \pgfmathsetmacro\y{ (\rinner + \noise) * sin(\ang) }
              \xdef\innerpoints{\innerpoints (\x,\y,\z)}
            }
            \addplot3[black, thick] coordinates {\innerpoints} --cycle;

            % Sample points inside the innermost level set
            \pgfmathsetseed{20260101 + \i}
            \def\dotpoints{}
            \pgfmathsetmacro\numdots{3*\i}
            \foreach \k in {1,...,\numdots}{
              \pgfmathsetmacro\rr{sqrt(rnd)*\rinner*0.9}
              \pgfmathsetmacro\tt{rnd*360}
              \pgfmathsetmacro\x{\rr * cos(\tt)}
              \pgfmathsetmacro\y{\rr * sin(\tt)}
              \xdef\dotpoints{\dotpoints (\x,\y,\z)}
            }
            \addplot3[red, only marks, mark=*, mark size=1] coordinates {\dotpoints};

            % Middle jagged circle
            \pgfmathsetmacro\r{sqrt(\z/0.2)}
            \def\middlepoints{}
            \foreach \sample in {1,...,40}{
              \pgfmathsetmacro\ang{360*\sample/40}
              \pgfmathsetmacro\noise{0.3 * rand}
              \pgfmathsetmacro\x{ (\r + \noise) * cos(\ang) }
              \pgfmathsetmacro\y{ (\r + \noise) * sin(\ang) }
              \xdef\middlepoints{\middlepoints (\x,\y,\z)}
            }
            \addplot3[black, thick] coordinates {\middlepoints} --cycle;

            % Outer bounding square
            \pgfmathsetmacro\h{sqrt(\z / 0.1)}
            \addplot3[black, thick] coordinates { (-\h, -\h, \z) (-\h, \h, \z) };
            \addplot3[black, thick] coordinates { (\h, -\h, \z) (\h, \h, \z) };
            \addplot3[black, thick] coordinates { (-\h, -\h, \z) (\h, -\h, \z) };
            \addplot3[black, thick] coordinates { (-\h, \h, \z) (\h, \h, \z) };
          }

        \end{axis}
        \path (current bounding box.north east) coordinate (plotNE);

        % Labels
        \node[font=\scriptsize, anchor=north west, inner sep=1pt] at ($(plotNE)+(-0.6, -1.3)$) {$\Sigma^{<80}$};
        \node[font=\scriptsize, anchor=north west, inner sep=1pt] at ($(plotNE)+(-0.9,-2.9)$)  {$\Sigma^{<60}$};
        \node[font=\scriptsize, anchor=north west, inner sep=1pt] at ($(plotNE)+(-1.5,-4.5)$)  {$\Sigma^{<40}$};
        \node[font=\scriptsize, anchor=north west, inner sep=1pt] at ($(plotNE)+(-2.2,-5.9)$)  {$\Sigma^{<20}$};
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{High-level grammar embedding recipe}

  \begin{itemize}\setlength\itemsep{0.35em}
  \item Fix a finite type universe $\mathbb{T}$ and an ambient global context $\Gamma$
  \item Decorate vanilla nonterminals with a typing annotation, $\nt{E}[\tau]$
  \item Each typing judgment becomes a schema for constructing a family of synthetic productions, each instantiated with $\tau : \mathbb{T}$
  \end{itemize}
  \vspace{0.2cm}
  \begin{align*}
    \textbf{Syntax:}&\quad
    \frac{\Gamma \vdash e_1:\tau_1,\ \cdots, e_m:\tau_m \qquad \Phi(\Sigma, \tau_1,\ \cdots,\tau_m):\tau}{\big(\nt{E}[\tau]\,\rightarrow\, \Phi(\Sigma, \tau_1,\ \cdots,\tau_m)\big)\in P_\Gamma}\\\\
    \textbf{Names:}&\quad
    \Gamma \vdash e:\tau \;\Rightarrow\; \big(\nt{E}[\tau]\,\rightarrow\,\tok{e}\big)\in P_\Gamma\\\\
    \textbf{Functions:}&\quad
    \frac{\Gamma \vdash f:(\tau_1,\ \cdots, \tau_k) \rightarrow \tau}{\big(\nt{E}[\tau_1]\,\rightarrow\,\tok{f}\gap\tok{(}\gap\nt{E}[\tau_1]\gap\tok{,}\gap \cdots\gap\tok{,}\gap\nt{E}[\tau_k]\gap\tok{)} \big)\in P_\Gamma}
  \end{align*}
  \begin{itemize}\setlength\itemsep{0.25em}
  \end{itemize}
\end{frame}

% -------------------------------------------------
\begin{frame}{Example language: simply typed function syntax}
  \vspace{-0.25cm}

  \[
    \hspace{-0.1cm}\begin{array}{ccl}
     \nt{FUN} & ::= & \tok{fun}\gap \tok{f0}\gap \tok{(}\gap \nt{PRM}\gap \tok{)}\gap \tok{:}\gap \mathbb{T} \gap \tok{=}\gap \nt{EXP} \\
     \nt{PRM} & ::= & \nt{PID}\gap \tok{:}\gap \mathbb{T} \;\mid\; \nt{PRM}\gap \tok{,}\gap \nt{PID}\gap \tok{:}\gap \mathbb{T} \\
     \nt{EXP} & ::= & \ulcorner\mathbb{N}\lrcorner \;\mid\; \ulcorner\mathbb{B}\lrcorner \;\mid\; \nt{PID} \;\mid\; \nt{INV} \;\mid\; \nt{IFE} \;\mid\; \nt{OPX}\\
     \nt{OPX} & ::= & \codett{(}\gap\nt{EXP}\gap \nt{OPR}\gap \nt{EXP}\gap\codett{)} \\
     \nt{IFE} & ::= & \tok{if}\gap \nt{EXP}\gap \tok{\{}\gap \nt{EXP}\gap \tok{\}}\gap
     \tok{else}\gap \tok{\{}\gap \nt{EXP}\gap \tok{\}} \\
     \nt{INV} & ::= & \nt{FID}\gap \tok{(}\gap \nt{ARG}\gap \tok{)} \\
     \nt{ARG} & ::= & \nt{EXP} \;\mid\; \nt{ARG}\gap \tok{,}\gap \nt{EXP} \\
     \nt{OPR} & ::= & \tok{+} \;\mid\; \tok{*} \;\mid\; \tok{<} \;\mid\; \tok{==} \\
     \nt{PID} & ::= & \tok{p1} \;\mid\; \ldots \;\mid\; \tok{pk} \\
     \nt{FID} & ::= & \tok{f0} \;\mid\; \tok{f1} \;\mid\; \ldots \;\mid\; \tok{fn}\\
     \ulcorner\mathbb{B}\lrcorner & ::= & \tok{true} \;\mid\; \tok{false}\\
     \ulcorner\mathbb{N}\lrcorner & ::= & \tok{1} \;\mid\; \tok{2} \;\mid\; \tok{3} \;\mid\; \ldots
    \end{array}
  \]

  \vspace{0.3cm}
  \textbf{Type universe:} Finite $\T$ with two primitive types (e.g., $\mathbb{B},\mathbb{N},\ldots$)\\\vspace{1em}
  \textbf{Ambient context:} $\Gamma$ maps $\tok{f\ttus}:(\tau_1,\ldots,\tau_m)\to\tau$.
\end{frame}

% -------------------------------------------------
\begin{frame}{Expression fragment: static semantics}
  \vspace{-0.3cm}
  \begin{center}
    \begin{prooftree}
      \hskip -1em
      \AxiomC{$\Gamma \vdash e_c: \mathbb{B}$}
      \AxiomC{$\Gamma \vdash e_\top: \tau$}
      \AxiomC{$\Gamma \vdash e_\bot: \tau$}
      \RightLabel{\texttt{IFE}}
      \TrinaryInfC{$\Gamma \vdash \tok{if}\; e_c\; \tok{\ttlb}\; e_\top\; \tok{\ttrb}\; \tok{else}\; \tok{\ttlb}\; e_\bot\; \tok{\ttrb} : \tau$}
\DisplayProof\vskip 2em\hskip -1em
      \hskip -1em
      \AxiomC{$\Gamma \vdash \tok{f\ttus}: (\tau_1,\ldots,\tau_m)\rightarrow\tau$}
      \AxiomC{$\Gamma \vdash e_i:\tau_i\;\;\forall i\in[1,m]$}
      \RightLabel{\texttt{INV}}
      \BinaryInfC{$\Gamma \vdash \tok{f\ttus}\;\tok{(}\; e_1\;\tok{,}\;\ldots\;\tok{,}\;e_m\;\tok{)}:\tau$}
\DisplayProof\vskip 2em\hskip -1em
      \AxiomC{$\delta_{\texttt{OPR}}(\odot,\tau,\tau')=\hat\tau$}
      \AxiomC{$\Gamma \vdash e_1:\tau$}
      \AxiomC{$\Gamma \vdash e_2:\tau'$}
      \RightLabel{\texttt{OPX}}
      \TrinaryInfC{$\Gamma \vdash \tok{(}\; e_1\; \odot\; e_2\; \tok{)} : \hat\tau$}
    \end{prooftree}
  \end{center}

  \vspace{0.1cm}

  \hspace{-0.5em}Where the operator typing function $\delta_{\texttt{OPR}}: \Sigma_{\texttt{OPR}} \times \mathbb{T} \times \mathbb{T} \rightharpoonup \mathbb{T}$ returns:

  \[
    \hspace{-3em}\delta_{\texttt{OPR}}(\odot,\tau,\tau')=
    \begin{cases}
      \mathbb{B} & \odot=\tok{<},\ \tau=\tau'=\mathbb{B}\\
      \mathbb{N} & \odot\in\{\tok{+},\tok{*}\},\ \tau=\tau'=\mathbb{N}\\
      \mathbb{B} & \odot=\tok{==},\ \tau=\tau'
    \end{cases}
  \]
\end{frame}

% -------------------------------------------------
\begin{frame}{Embedding the type checker (I)}
  \vspace{-0.45cm}
  \[
    \textbf{Grammar:}\quad \langle \Sigma, V, P \textcolor{gray}{\ \subset V\times (V \cup \Sigma)^*}, S \textcolor{gray}{\ \in V}\rangle \Rightarrow \langle \Sigma_\Gamma, V_\Gamma, P_\Gamma, V_\Gamma, S_\Gamma\rangle\\\vspace{-0.5em}
    \textbf{Decorated nonterminals:}\quad \nt{EXP}[\tau,\pi] \qquad \big(\tau\in\T,\;\pi\equiv(\vec\tau\rightarrow\dot\tau)\big)\\\vspace{0.5em}
    \textbf{Provide:} \quad $k$ \text{, the maximum arity, and } $\mathbb{T}$ \text{, the type universe}.
  \]
\vspace{-1.6cm}
  \begin{center}
    \begin{prooftree}
      \AxiomC{$\langle\vec\tau,\dot\tau\rangle \in \T^{0..k}\times\T$}
      \AxiomC{$\vec\tau_{0..|\vec\tau|} \in \vec\tau$}
      \RightLabel{$\texttt{FUN}_{\varphi}$}
      \BinaryInfC{$\Big(S_\Gamma \rightarrow
      \tok{fun}\;\tok{f0}\;
      \tok{(}\;\cjoin{i=1}{|\vec\tau|}\big(p_i\;\tok{:}\;\vec\tau_i\big)\;\tok{)}\;
      \tok{:}\;\dot\tau\;\tok{=}\;\nt{EXP}[\dot\tau,\vec\tau\rightarrow\dot\tau]
      \Big)\in P_\Gamma$}
\DisplayProof\vskip 1.5em\hskip -1em
      \AxiomC{$\nt{EXP}[\tau,\vec\tau\rightarrow\dot\tau] \in V_\Gamma$}
      \AxiomC{$\tau=\dot\tau$}
      \AxiomC{$\vec\tau_{0..|\vec\tau|}\in\vec\tau$}
      \RightLabel{$\texttt{REC}_{\varphi}$}
      \TrinaryInfC{$\big(\nt{EXP}[\tau,\vec\tau\rightarrow\dot\tau] \rightarrow
      \tok{f0}\;\tok{(}\;\cjoin{i=1}{|\vec\tau|}\nt{EXP}[\vec\tau_i,\vec\tau\rightarrow\dot\tau]\;\tok{)}
      \big)\in P_\Gamma$}
\DisplayProof\vskip 1.5em\hskip -0.1em
      \AxiomC{$\nt{EXP}[\tau,\vec\tau\rightarrow\dot\tau]\in V_\Gamma\;\;\exists i.\ \vec\tau_i=\tau$}
      \RightLabel{$\texttt{PID}_{\varphi}$}
      \UnaryInfC{$\big(\nt{EXP}[\tau,\vec\tau\rightarrow\dot\tau]\rightarrow\tok{pi}\big)\in P_\Gamma$}
      \DisplayProof\hskip 9.9em
      \AxiomC{$\nt{EXP}[\tau,\pi]\in V_\Gamma\;\;\tok{\ttus}: \mathbb{B} \mid \mathbb{N}$}
      \RightLabel{$\ulcorner\T\lrcorner_{\varphi}$}
      \UnaryInfC{$\big(\nt{EXP}[\tau,\pi]\rightarrow\tok{\ttus}\big)\in P_\Gamma$}\hskip -9.9em
    \end{prooftree}
  \end{center}
\end{frame}

% -------------------------------------------------
\begin{frame}{Embedding the type checker (II)}
  \vspace{-0.35cm}
  \begin{center}
    \begin{prooftree}
      \vskip -1em\hskip -0.6cm
      \AxiomC{$\nt{EXP}[\tau,\pi] \in V_\Gamma$}
      \AxiomC{$\Gamma \vdash \tok{f\ttus}:(\tau_1,\ldots,\tau_m)\rightarrow\tau$}
      \RightLabel{$\texttt{INV}_{\varphi}$}
      \BinaryInfC{$\big(\nt{EXP}[\tau,\pi] \rightarrow
      \tok{f\ttus}\;\tok{(}\;\cjoin{i=1}{m}\nt{EXP}[\tau_i,\pi]\;\tok{)}
      \big)\in P_\Gamma$}
\DisplayProof\vskip 2em\hskip -1em
      \AxiomC{$\nt{EXP}[\tau,\pi]\in V_\Gamma$}
      \AxiomC{$\tau=\tau'$}
      \AxiomC{$\tau,\tau'\in\T$}
      \RightLabel{$\texttt{IFE}_{\varphi}$}
      \TrinaryInfC{$\Big(
      \nt{EXP}[\tau,\pi] \rightarrow
      \tok{if}\;\nt{EXP}[\mathbb{B},\pi]\;\tok{\ttlb}\;\nt{EXP}[\tau,\pi]\;\tok{\ttrb}\;
      \tok{else}\;\tok{\ttlb}\;\nt{EXP}[\tau',\pi]\;\tok{\ttrb}
      \Big)\in P_\Gamma$}
\DisplayProof\vskip 2em\hskip -1em
      \AxiomC{$\nt{EXP}[\hat\tau,\pi]\in V_\Gamma$}
      \AxiomC{$\delta_{\texttt{OPR}}(\odot,\tau,\tau')=\hat\tau$}
      \AxiomC{$\odot\in\{\tok{==},\tok{<},\tok{+},\tok{*}\}$}
      \RightLabel{$\texttt{OPX}_{\varphi}$}
      \TrinaryInfC{$\Big(
      \nt{EXP}[\hat\tau,\pi] \rightarrow
      \tok{(}\;\nt{EXP}[\tau,\pi]\;\odot\;\nt{EXP}[\tau',\pi]\;\tok{)}
      \Big)\in P_\Gamma$}
    \end{prooftree}
  \end{center}
\vspace{1em}
  Finally, we normalize to Chomsky Normal Form (CNF), rewriting all productions to either \textbf{(1)} $(w \rightarrow x z): V\times V^2$ or \textbf{(2)} $(w \rightarrow t): V\times\Sigma$.
\end{frame}

\begin{frame}{Addendum: CFG $\cap$ NFA closure and $G_\cap$ construction}
  \textbf{Bar-Hillel (1961)}: For any CFG $G$, and NFA
  $A=\langle Q,\Sigma,\delta,q_\alpha,F\rangle$, $\exists G_\cap$ s.t.
  $\mathcal{L}(G_\cap)=\mathcal{L}(G)\cap\mathcal{L}(A)$. Salomaa's (1973) construction:

  \vspace{-0.1cm}
  \begin{center}
    \begin{prooftree}
      \AxiomC{$q_\omega \in F$}
      \RightLabel{$\mathcal{S}$}
      \UnaryInfC{$\big(S_\cap \rightarrow q_\alpha\, S\, q_\omega\big)\in P_\cap$}
      \DisplayProof\hspace{0.5em}
      \AxiomC{$(W\rightarrow a)\in P$}
      \AxiomC{$(p\overset{a}{\rightarrow}r)\in\delta$}
      \RightLabel{$\uparrow$}
      \BinaryInfC{$\big(pWr\rightarrow a\big)\in P_\cap$}
      \DisplayProof\vskip1em
      \AxiomC{$(W\rightarrow XZ)\in P$}
      \AxiomC{$p,q,r\in Q$}
      \RightLabel{$\Join$}
      \BinaryInfC{$\big(pWr\rightarrow (pXq)\,(qZr)\big)\in P_\cap$}
    \end{prooftree}
  \end{center}

  \vspace{0.1cm}
  but, there is a \textit{much} more efficient construction. Intuition: want to show $q_\alpha \rightsquigarrow q_\omega$ in $A$ such that $q_\omega: F$ where $q_\alpha \rightsquigarrow q_\omega \vdash S$. At least one of two cases must hold for $w \in V$ to parse a given $p \rightsquigarrow r$ pair:
  \begin{enumerate}\setlength\itemsep{0.25em}
    \item $\exists a.\big((p \overset{a}{\rightarrow} r)\in \delta \land (w \rightarrow a) \in P\big)$, or,
    \item $\exists q, x, z.\big((w \rightarrow xz) \in P\land\overbrace{\underbrace{p \rightsquigarrow q}_x, \underbrace{q \rightsquigarrow r}_z}^w\big)$.
  \end{enumerate}
\end{frame}

\begin{frame}{Repair example: Simple Levenshtein automaton}
  Suppose we have the string, $\err\sigma=\texttt{())}$ and wish to balance the parentheses. Assume we have the Chomsky Normal Form CFG, $G'= \big\{S \rightarrow L R, S \rightarrow L F, S \rightarrow S S, F \rightarrow S R, L \rightarrow \hspace{-0.05cm}\texttt{(}, R \rightarrow\hspace{-0.05cm}\texttt{)}\big\}$ and let us impose an ordering of $S, F, L, R$ on $V$.
  We will initially have the Levenshtein automaton, $A$, depicted below.

  \vspace{0.5cm}
  \centering
  \begin{adjustbox}{max size={0.95\textwidth}{0.62\textheight},center}
    \begin{tikzpicture}[
%->, % makes the edges directed
  >=stealth',
  node distance=2.5cm, % specifies the minimum distance between two nodes. Change if necessary.
%  every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
  initial text=$ $, % sets the text that appears on the start arrow
]
  \node[state, initial]                (00) {$q_{0,0}$};
  \node[state, right of=00]            (10) {$q_{1,0}$};
  \node[accepting, state, right of=10] (20) {$q_{2,0}$};
  \node[accepting, state, right of=20] (30) {$q_{3,0}$};

  \node[state, above of=00, shift={(-2cm,0cm)}] (01) {$q_{0,1}$};
  \node[state, right of=01]                     (11) {$q_{1,1}$};
  \node[state, right of=11]                     (21) {$q_{2,1}$};
  \node[accepting, state, right of=21]          (31) {$q_{3,1}$};

  \draw [->] (00) edge[below] node{\tiny{$\texttt{(}$}} (10);
  \draw [->] (10) edge[below] node{\tiny{$\texttt{)}$}} (20);
  \draw [->] (20) edge[below] node{\tiny{$\texttt{)}$}} (30);

  \draw [->] (01) edge[below] node{\tiny{$\texttt{(}$}}                       (11);
  \draw [->] (11) edge[below] node[shift={(-0.2cm,0cm)}]{\tiny{$\texttt{)}$}} (21);
  \draw [->] (21) edge[below] node[shift={(-0.2cm,0cm)}]{\tiny{$\texttt{)}$}} (31);

  \draw [->] (00) edge[left] node{\tiny{$\texttt{)}$}} (11);
  \draw [->] (10) edge[left] node{\tiny{$\texttt{(}$}} (21);
  \draw [->] (20) edge[left] node{\tiny{$\texttt{(}$}} (31);

  \draw [->] (00) edge[bend left=10, left] node{\tiny{$\texttt{)}$}} (01);
  \draw [->] (10) edge[bend left=10, left] node{\tiny{$\texttt{(}$}} (11);
  \draw [->] (20) edge[bend left=10, left] node{\tiny{$\texttt{(}$}} (21);
  \draw [->] (30) edge[bend left=10, left] node{\tiny{$\texttt{)|(}$}} (31);

  \draw [->, blue] (00) edge[bend right=11,below] node[shift={(0.2cm,0.8cm)}]{\tiny{$\texttt{)}$}}    (21);
  \draw [->, blue] (10) edge[bend right=11,below] node[shift={(0.2cm,0.8cm)}]{\tiny{$\texttt{)}$}}    (31);
\end{tikzpicture}
  \end{adjustbox}
\end{frame}

%\begin{frame}{Pairing function over $L(\sigma:\Sigma^3,1)$}
%  \centering
%  \begin{adjustbox}{max size={1.98\textwidth}{0.88\textheight},center}
%    \input{../../popl2026/figures/partial_order}
%  \end{adjustbox}
%\end{frame}
%
%\begin{frame}{Adjacency and reachability matrix}
%  \centering
%  \begin{adjustbox}{max size={1.98\textwidth}{0.88\textheight},center}
%    \input{../../popl2026/figures/adj_mat}
%  \end{adjustbox}
%\end{frame}

\begin{frame}{Repair example: Initial parse chart configuration}
  \centering
  \begin{adjustbox}{max size={0.98\textwidth}{0.88\textheight},center}
    \input{../../popl2026/figures/pc_init}
  \end{adjustbox}
\end{frame}

\begin{frame}{Repair example: Final parse chart configuration}
  \centering
  \begin{adjustbox}{max size={0.98\textwidth}{0.88\textheight},center}
    \input{../../popl2026/figures/pc_final}
  \end{adjustbox}
\end{frame}

\begin{frame}{Repair example: Regular expression denoting $\mathcal{L}(G) \cap \alpha_\varnothing$}
  \centering
  (abab | (ab | aabb)) | (abab | aabb)
  \vspace{0.5cm}
  \begin{adjustbox}{max size={0.98\textwidth}{0.88\textheight},center}
    \includegraphics{../../popl2026/figures/gre}
  \end{adjustbox}
\end{frame}

\begin{frame}{Sampling star-free regular expressions uniformly}
  \vspace{-0.3cm}

  Let \( e: E \) be an SFRE with two connectives: $ e \rightarrow \Sigma \mid e \cdot e \mid e \lor e $.

  \begin{theorem}[Uniform tree enumeration]
    To sample parse trees, take a PRNG and feed it into \texttt{enum}:
    \begin{equation*}
      \texttt{enum}\,(e, n) = \begin{cases}
        e &\text{if } e \in \Sigma \\
        \texttt{enum}\,\big(x, \lfloor \frac{n}{|z|} \rfloor\big) \cdot \texttt{enum}\,\big(z,\, n \bmod |z|\big)  &\text{if } e = x \cdot z \\
        \texttt{enum}\,\big((x, z)_{\min(1, \lfloor\frac{n}{|x|}\rfloor)}, n-|x|\min(1, \lfloor\frac{n}{|x|}\rfloor)\big) &\text{if } e = x \vee z
      \end{cases}
    \end{equation*}

    Where the number of parse trees in a SFRE we abbreviate as $|e|$:

    \begin{equation*}
      |e|: E \rightarrow \mathbb{N} = \begin{cases}
        1           & \text{if } e \in \Sigma \\
        x \times z  & \text{if } e = x \cdot z \\
        x + z       & \text{if } e = x \vee z
      \end{cases}
    \end{equation*}

    n.b. we may need to disambiguate to guarantee $\mathcal{L}(e)$ uniformity.
  \end{theorem}
\end{frame}

\begin{frame}{Sampling star-free regular expressions autoregressively}

%  \begin{multicols}{2}
%    \begin{eqnarray*}
%      \phantom{--}\partial_a(&\hspace{-0.35cm} \varnothing \hspace{-0.35cm}&) = \varnothing                                           \\
%      \phantom{--}\partial_a(&\hspace{-0.35cm} \varepsilon \hspace{-0.35cm}&) = \varnothing                                           \\\\[-0.5cm]
%      \phantom{--}\partial_a(&\hspace{-0.35cm} b           \hspace{-0.35cm}&) = \begin{cases}\varepsilon &\text{ if } a = b\\ \varnothing &\text{ if } a \neq b \end{cases}\\\\
%      \phantom{--}\partial_a(&\hspace{-0.35cm} x\cdot z    \hspace{-0.35cm}&) = (\partial_a x)\cdot z \vee \delta(x)\cdot\partial_a z \\
%      \phantom{--}\partial_a(&\hspace{-0.35cm} x\vee  z    \hspace{-0.35cm}&) =  \partial_a x \vee  \partial_a z                       \\
%      \phantom{--}\partial_a(&\hspace{-0.35cm} x\land z    \hspace{-0.35cm}&) =  \partial_a x \land \partial_a z
%    \end{eqnarray*} \break\vspace{-0.45cm}
%    \begin{eqnarray*}
%      \delta(&\hspace{-0.35cm} \varnothing \hspace{-0.35cm}&) = \varnothing                                      \\
%      \delta(&\hspace{-0.35cm} \varepsilon \hspace{-0.35cm}&) = \varepsilon                                      \\\\[-0.5cm]
%      \delta(&\hspace{-0.35cm} a           \hspace{-0.35cm}&) = \varnothing\phantom{\begin{cases}\varepsilon\\\varnothing\end{cases}}\\\\
%      \delta(&\hspace{-0.35cm} x\cdot z    \hspace{-0.35cm}&) = \delta(x) \land \delta(z)                        \\
%      \delta(&\hspace{-0.35cm} x\vee  z    \hspace{-0.35cm}&) = \delta(x) \vee  \delta(z)                        \\
%      \delta(&\hspace{-0.35cm} x\land z    \hspace{-0.35cm}&) = \delta(x) \land \delta(z)
%    \end{eqnarray*}
%  \end{multicols}

  Now, for any SFGRE, \(e\), $\texttt{choose}\,(e)$ witnesses $\sigma \in \mathcal{L}(e)$:
  \begin{equation*}
    \texttt{follow}\,(e) = \begin{cases}
           \{e\}                                        &\hspace{1.3cm}\text{ if } e \in \Sigma \\
           \texttt{follow}\,(x)                         &\hspace{1.3cm}\text{ if } e = x \cdot z\\
           \texttt{follow}\,(x)\cup\texttt{follow}\,(z) &\hspace{1.3cm}\text{ if } e = x \lor z
    \end{cases}
  \end{equation*}
  \begin{equation*}\label{eq:choose}
    \texttt{choose}\,(e) = \begin{cases}
         e &\text{ if } e \in \Sigma \\
         \big(s \leftsquigarrow \texttt{follow}\,(e)\big)\cdot \texttt{choose}\,(\partial_s e) &\text{ if } e = x \cdot z\\
         \texttt{choose}\,\big(e' \leftsquigarrow \{x, z\}\big) &\text{ if } e = x \lor z
    \end{cases}
  \end{equation*}
\vspace{0.2cm}

  where $\delta_s e$ is the Brzozowskian derivative (1973) and $\leftsquigarrow$ denotes probabilistic choice from a small finite set. This may be augmented with a weighted choice operator, $\sigma \leftsquigarrow P_\theta\,(\sigma_{n} \mid  \sigma_{n-1}, \cdots, \sigma_{n - k})$.
\end{frame}
\end{document}